<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Basis Vector Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3NU" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUbKyIyuh" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
            background-color: #000;
        }
        #katex-output {
            font-size: 1.125rem; /* Reduced font size */
        }
        #container {
            flex-grow: 1;
            min-height: 0;
            position: relative;
        }
        canvas { display: block; }
        .slider-label-x { color: #ef4444; }
        .slider-label-y { color: #22c55e; }
        .slider-label-z { color: #3b82f6; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 20px; height: 20px;
            border-radius: 50%; cursor: pointer;
        }
        input[type=range].slider-x::-webkit-slider-thumb { background-color: #ef4444; }
        input[type=range].slider-y::-webkit-slider-thumb { background-color: #22c55e; }
        input[type=range].slider-z::-webkit-slider-thumb { background-color: #3b82f6; }

        /* Smaller label for vector norm */
        #norm-label {
            position: absolute;
            background-color: rgba(30, 41, 59, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #4b5563;
            font-size: 0.8rem;
            white-space: nowrap;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
            transform: translate(-50%, -120%);
            opacity: 0;
            visibility: hidden;
        }
        #norm-label.visible { opacity: 1; visibility: visible; }
        #norm-label::after {
            content: ''; position: absolute;
            left: 50%; top: 100%;
            transform: translateX(-50%);
            width: 1px; height: 15px;
            background: linear-gradient(to bottom, #4b5563, transparent);
        }
    </style>
</head>
<body class="bg-black text-white">

    <header class="bg-gray-900/50 p-4 shadow-lg z-10 backdrop-blur-sm">
        <h1 class="text-2xl md:text-3xl font-bold text-center">3D Basis Vectors</h1>
        <div id="katex-output" class="text-center mt-2 p-2 bg-black/30 rounded-lg min-h-[3rem] flex items-center justify-center"></div>
    </header>

    <main id="container">
        <div id="norm-label"></div>
    </main>

    <footer class="bg-gray-900/50 p-4 shadow-lg z-10 backdrop-blur-sm">
        <div class="max-w-4xl mx-auto">
             <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-center">
                <div class="flex items-center space-x-3">
                    <label class="font-bold slider-label-x w-12 text-center">î (x)</label>
                    <input id="x-slider" type="range" min="-5" max="5" value="1" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider-x">
                    <span id="x-value" class="px-2 py-1 text-sm rounded-md bg-red-500/20 w-16 text-center">1.00</span>
                </div>
                <div class="flex items-center space-x-3">
                    <label class="font-bold slider-label-y w-12 text-center">ĵ (y)</label>
                    <input id="y-slider" type="range" min="-5" max="5" value="1" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider-y">
                    <span id="y-value" class="px-2 py-1 text-sm rounded-md bg-green-500/20 w-16 text-center">1.00</span>
                </div>
                <div class="flex items-center space-x-3">
                    <label class="font-bold slider-label-z w-12 text-center">k̂ (z)</label>
                    <input id="z-slider" type="range" min="-5" max="5" value="1" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider-z">
                    <span id="z-value" class="px-2 py-1 text-sm rounded-md bg-blue-500/20 w-16 text-center">1.00</span>
                </div>
            </div>
        </div>
    </footer>
    
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const container = document.getElementById('container');
        if (!container) { 
            console.error("Container element not found."); 
        } else {

            // --- Scene ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(4, 5, 6);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // --- Helpers ---
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            // --- Custom Thick Arrow ---
            function createThickArrow(color, name) {
                const group = new THREE.Group();
                group.name = name;
                const shaftRadius = 0.035;
                const headRadius = 0.08;
                const headHeight = 0.25;
                const material = new THREE.MeshBasicMaterial({ color });

                const shaftGeo = new THREE.CylinderGeometry(shaftRadius, shaftRadius, 1, 16);
                shaftGeo.translate(0, 0.5, 0); 
                const shaft = new THREE.Mesh(shaftGeo, material);
                group.add(shaft);

                const headGeo = new THREE.ConeGeometry(headRadius, headHeight, 16);
                headGeo.translate(0, headHeight / 2, 0);
                const head = new THREE.Mesh(headGeo, material);
                group.add(head);
                return group;
            }

            // --- Axis Labels ---
            function createAxisLabel(text, color, size = 64) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const font = `${size}px Arial`;
                context.font = font;
                const textWidth = context.measureText(text).width;
                canvas.width = textWidth;
                canvas.height = size;
                context.font = font; 
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(canvas.width / size * 0.7, 0.7, 1);
                return sprite;
            }

            // --- Scene Objects ---
            const axisI = createThickArrow(0xef4444, 'i');
            axisI.rotation.z = -Math.PI / 2;
            const axisJ = createThickArrow(0x22c55e, 'j');
            const axisK = createThickArrow(0x3b82f6, 'k');
            axisK.rotation.x = Math.PI / 2;
            scene.add(axisI, axisJ, axisK);

            const labelI = createAxisLabel('î', '#ef4444', 5000);
            const labelJ = createAxisLabel('ĵ', '#22c55e', 5000);
            const labelK = createAxisLabel('k̂', '#3b82f6', 5000);

            labelI.position.set(5.8, 0, 0);
            labelJ.position.set(0, 5.8, 0);
            labelK.position.set(0, 0, 5.8);

            const scale = 0.5;
  

            // scale down to make smaller
            labelI.scale.set(0.45*scale, 1*scale, 0);
            labelJ.scale.set(0.45*scale, 1*scale, 0);
            labelK.scale.set(0.45*scale, 1*scale, 0);

            scene.add(labelI, labelJ, labelK);


            



            const resultantVector = new THREE.Vector3(1, 1, 1);
            const arrowResultant = new THREE.ArrowHelper(resultantVector.clone().normalize(), new THREE.Vector3(0,0,0), resultantVector.length(), 0xffffff, 0.25, 0.15);
            arrowResultant.name = 'resultant';
            scene.add(arrowResultant);

            // --- UI and Interaction ---
            const [xSlider, ySlider, zSlider] = ['x', 'y', 'z'].map(id => document.getElementById(`${id}-slider`));
            const [xValueSpan, yValueSpan, zValueSpan] = ['x', 'y', 'z'].map(id => document.getElementById(`${id}-value`));
            const latexOutputDiv = document.getElementById('katex-output');
            const normLabel = document.getElementById('norm-label');
            let selectedObject = null;
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            function updateVectors() {
                const x = parseFloat(xSlider.value);
                const y = parseFloat(ySlider.value);
                const z = parseFloat(zSlider.value);

                xValueSpan.textContent = x.toFixed(2);
                yValueSpan.textContent = y.toFixed(2);
                zValueSpan.textContent = z.toFixed(2);
                
                [axisI, axisJ, axisK].forEach(axis => {
                    const val = axis === axisI ? x : (axis === axisJ ? y : z);
                    const shaft = axis.children[0];
                    const head = axis.children[1];
                    
                    const headHeight = 0.25;
                    const totalLength = Math.abs(val);
                    const shaftLength = Math.max(0, totalLength - headHeight);
                    
                    shaft.scale.y = shaftLength;
                    head.position.y = shaftLength;
                    
                    axis.visible = totalLength > 0.001;
                    
                    // FIX: Always scale on the local Y-axis, which is the axis of the arrow's construction.
                    // This correctly flips the arrow's direction regardless of the parent group's rotation.
                    axis.scale.y = (val < 0) ? -1 : 1;
                });
                
                resultantVector.set(x, y, z);
                const length = resultantVector.length();
                arrowResultant.visible = length > 0.001;
                if (arrowResultant.visible) {
                    arrowResultant.setDirection(resultantVector.clone().normalize());
                    arrowResultant.setLength(length, 0.25, 0.15);
                }

                const xStr = x.toFixed(2);
                const yStr = y >= 0 ? `+ ${y.toFixed(2)}` : `- ${Math.abs(y).toFixed(2)}`;
                const zStr = z >= 0 ? `+ ${Math.abs(z).toFixed(2)}` : `- ${Math.abs(z).toFixed(2)}`;
                katex.render(`\\vec{v} = \\textcolor{#ef4444}{${xStr}\\hat{\\imath}} \\textcolor{#22c55e}{${yStr}\\hat{\\jmath}} \\textcolor{#3b82f6}{${zStr}\\hat{k}}`, latexOutputDiv, { throwOnError: false });
                if (selectedObject) updateNormLabelContent();
            }

            function updateNormLabelContent() {
                if (!selectedObject) return;
                const x = parseFloat(xSlider.value), y = parseFloat(ySlider.value), z = parseFloat(zSlider.value);
                let latexString = '';
                if (selectedObject.name === 'i') latexString = `||${x.toFixed(2)}\\hat{\\imath}|| = ${Math.abs(x).toFixed(2)}`;
                else if (selectedObject.name === 'j') latexString = `||${y.toFixed(2)}\\hat{\\jmath}|| = ${Math.abs(y).toFixed(2)}`;
                else if (selectedObject.name === 'k') latexString = `||${z.toFixed(2)}\\hat{k}|| = ${Math.abs(z).toFixed(2)}`;
                else if (selectedObject.name === 'resultant') latexString = `||\\vec{v}|| = \\sqrt{(${x.toFixed(2)})^2 + (${y.toFixed(2)})^2 + (${z.toFixed(2)})^2} = ${resultantVector.length().toFixed(2)}`;
                katex.render(latexString, normLabel, { throwOnError: false, displayMode: false });
            }

            container.addEventListener('click', (event) => {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([axisI, axisJ, axisK, arrowResultant], true);

                if (intersects.length > 0) {
                    let parent = intersects[0].object;
                    while (parent && !parent.name) parent = parent.parent;
                    if (parent) {
                        selectedObject = parent;
                        updateNormLabelContent();
                        normLabel.classList.add('visible');
                    }
                } else {
                    selectedObject = null;
                    normLabel.classList.remove('visible');
                }
            });

            [xSlider, ySlider, zSlider].forEach(s => s.addEventListener('input', updateVectors));

            // --- Loop and Resize ---
            const tipPosition = new THREE.Vector3();
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                if (selectedObject && normLabel.classList.contains('visible')) {
                    const targetObject = selectedObject.name === 'resultant' ? selectedObject.cone : selectedObject.children[1];
                    targetObject.getWorldPosition(tipPosition);
                    if (selectedObject.name !== 'resultant') {
                        const direction = new THREE.Vector3();
                        targetObject.getWorldDirection(direction);
                        tipPosition.addScaledVector(direction, 0.25);
                    }
                    tipPosition.project(camera);
                    normLabel.style.left = `${(tipPosition.x * .5 + .5) * container.clientWidth}px`;
                    normLabel.style.top = `${(tipPosition.y * -.5 + .5) * container.clientHeight}px`;
                }
                renderer.render(scene, camera);
            }

            const resizeObserver = new ResizeObserver(() => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
            resizeObserver.observe(container);

            updateVectors();
            animate();
        }
    </script>
</body>
</html>

