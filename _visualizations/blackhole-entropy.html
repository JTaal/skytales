<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Interactive Black Hole Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #030712; /* bg-gray-950 */
            color: #e5e7eb;
        }
        .ui-panel {
            position: absolute;
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(8px);
            padding: 1.25rem;
            border: 1px solid rgba(55, 65, 81, 0.7);
            transition: all 0.5s ease-in-out;
            z-index: 10;
        }
        #info-panel {
            top: 80px;
            left: 20px;
            max-width: 420px;
            cursor: pointer;
            overflow: hidden;
            border-radius: 12px;
            max-height: 58px; /* Collapsed */
        }
        #info-panel.expanded {
            max-height: 90vh; 
            cursor: default;
            overflow-y: auto;
            z-index: 11;
        }
        #info-header { display: flex; justify-content: space-between; align-items: center; }
        #toggle-icon { transition: transform 0.3s ease-in-out; }
        #info-panel.expanded #toggle-icon { transform: rotate(180deg); }
        .formula {
            font-family: 'Georgia', serif;
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            font-size: 1.2rem;
            margin-top: 1rem;
            color: #d1d5db;
            border: 1px solid #374151;
            overflow-x: auto;
        }
        #controls-panel {
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            border-radius: 12px 12px 0 0;
            padding: 1rem 2rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
        }
        header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: center; /* Centered title */
            align-items: center;
            padding: 1rem 1.5rem;
            background-color: rgba(3, 7, 18, 0.5);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(55, 65, 81, 0.7);
        }
        .toggle-button {
            background-color: rgba(55, 65, 81, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(75, 85, 99, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
            font-size: 0.875rem;
        }
        .toggle-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }
        .toggle-button.active {
            background-color: #4f46e5;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: #4b5563;
            border-radius: 2px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #818cf8;
            cursor: pointer;
            border-radius: 50%;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .hidden { display: none !important; }
        canvas { display: block; }

        #settings-button, #fullscreen-button {
            position: absolute;
            background-color: rgba(55, 65, 81, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(75, 85, 99, 0.9);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }
        #settings-button {
            top: 80px;
            right: 20px;
            z-index: 11;
        }
        #fullscreen-button {
            bottom: 120px;
            right: 20px;
            z-index: 11;
        }
        #settings-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px) rotate(45deg);
        }
        #fullscreen-button:hover {
             background-color: #4338ca;
            transform: translateY(-2px) scale(1.1);
        }
        #settings-panel {
            top: 80px;
            right: 0;
            width: 300px;
            max-width: 90vw;
            border-radius: 12px 0 0 12px;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            padding-right: 2rem; 
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            z-index: 12;
        }
        #settings-panel::-webkit-scrollbar { width: 12px; }
        #settings-panel::-webkit-scrollbar-track { background: rgba(17, 24, 39, 0.1); }
        #settings-panel::-webkit-scrollbar-thumb {
            background-color: #4f46e5;
            border-radius: 10px;
            border: 3px solid rgba(17, 24, 39, 0.85); 
            background-clip: padding-box;
        }
        #settings-panel::-webkit-scrollbar-thumb:hover { background-color: #6366f1; }
        #settings-panel.open { transform: translateX(0); }
        #close-settings {
            font-size: 2.5rem;
            line-height: 1;
            padding: 0;
            background: none;
            border: none;
            cursor: pointer;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 100%;
            height: 40px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch { border-radius: 8px; border: 1px solid #4b5563; }
        input[type="color"]::-moz-color-swatch { border-radius: 8px; border: 1px solid #4b5563; }

        body.fullscreen-active header,
        body.fullscreen-active #info-panel { display: none !important; }

        body.fullscreen-active #controls-panel,
        body.fullscreen-active #settings-button,
        body.fullscreen-active #fullscreen-button {
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }
        
        body.fullscreen-active #controls-panel.show-on-hover,
        body.fullscreen-active #settings-button.show-on-hover,
        body.fullscreen-active #fullscreen-button.show-on-hover {
            opacity: 1;
            pointer-events: auto;
            visibility: visible;
        }
        
        @media (max-width: 768px) {
            header { padding: 0.75rem 1rem; }
            header h1 { font-size: 1.125rem; }
            #info-panel { top: 70px; left: 10px; right: 10px; max-width: none; width: auto; }
            #settings-button { top: 70px; right: 10px; }
            #fullscreen-button { bottom: 100px; right: 10px; }
            #settings-panel { top: 70px; width: 280px; max-height: calc(100vh - 80px);}
            #controls-panel { padding: 0.75rem; gap: 0.75rem; justify-content: space-around; }
            .control-group { gap: 0.25rem; }
            #controls-panel .text-3xl { font-size: 1.5rem; }
            #controls-panel label, #controls-panel .text-sm, #controls-panel .text-xs { font-size: 0.75rem; }
            input[type="range"]::-webkit-slider-thumb { width: 24px; height: 24px; }
        }
    </style>
</head>
<body>
    <header>
        <h1 class="text-xl font-bold text-gray-200 tracking-wider opacity-90">Black Hole Simulator</h1>
    </header>

    <div id="info-panel" class="ui-panel">
        <div id="info-header">
            <h2 id="info-title" class="text-xl font-bold text-indigo-400">Black Hole Simulator</h2>
            <div id="toggle-icon" class="text-indigo-400">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
            </div>
        </div>
        <div id="info-content" class="pt-4 space-y-3">
             <p id="info-description" class="text-gray-300">This simulation visualizes how mass-energy ($T_{\mu\nu}$) curves spacetime according to Einstein's Field Equations. You can control the mass of the central object and observe its effects on the surrounding fabric of spacetime, particles, and light rays.</p>
             <div id="info-formula" class="formula">G<sub>&mu;&nu;</sub> = R<sub>&mu;&nu;</sub> - &frac12;R g<sub>&mu;&nu;</sub> = (8&pi;G/c<sup>4</sup>)T<sub>&mu;&nu;</sub></div>
             <div id="blackhole-explanation-content">
                 <h3 class="font-bold text-lg text-purple-400 mt-4">Visualizing Spacetime</h3>
                 <p class="text-sm text-gray-300">The grid represents the fabric of spacetime, which is distorted by the mass of the central object. The flowing particles represent matter following "geodesics"—the straightest possible paths through this curved space.</p>
                 <p class="text-sm text-gray-300 mt-2">Light rays are also bent by gravity. They appear blue (blueshifted) when falling towards the gravity well and lose energy, becoming red (redshifted) as they escape.</p>
             </div>
        </div>
    </div>

    <div id="controls-panel" class="ui-panel"></div>

    <button id="fullscreen-button" title="Toggle Fullscreen">
        <svg id="fullscreen-enter-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
        </svg>
        <svg id="fullscreen-exit-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/>
        </svg>
    </button>
    <button id="settings-button" title="Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0 2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    </button>
    
    <div id="settings-panel" class="ui-panel hidden">
        <div class="flex justify-between items-center mb-6 sticky top-0 bg-inherit z-10 py-2">
            <h3 class="text-xl font-bold text-gray-200">Settings</h3>
            <button id="close-settings" class="text-gray-400 hover:text-white transition-colors">&times;</button>
        </div>
        <div class="space-y-6">
            <div class="control-group text-left w-full">
                <label class="text-sm font-medium self-start w-full">VR Mode</label>
                <button id="vr-button" title="Enter VR Mode" class="toggle-button w-full flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M2 12.3C2 7.8 5.8 4 10.3 4s8.3 3.8 8.3 8.3-3.5 8.3-8.3 8.3S2 16.8 2 12.3z"/>
                        <path d="M12.3 4a8.3 8.3 0 0 1 8.3 8.3 8.3 8.3 0 0 1-8.3 8.3"/>
                    </svg>
                    <span>Enter VR</span>
                </button>
            </div>
            <div class="control-group text-left w-full">
                <label class="text-sm font-medium self-start w-full">Follow Object</label>
                <button id="follow-toggle" class="toggle-button">Off</button>
            </div>
            <div class="control-group text-left w-full">
                <label for="light-speed-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Light Speed / Time Flow:</span>
                    <span id="light-speed-value">999x</span>
                </label>
                <input id="light-speed-slider" type="range" min="0.1" max="1000" step="1" value="999" class="w-full">
            </div>
            <div class="control-group text-left w-full">
                <label for="trace-length-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Light Ray Trace Length:</span>
                    <span id="trace-length-value">40</span>
                </label>
                <input id="trace-length-slider" type="range" min="5" max="100" step="1" value="40" class="w-full">
            </div>
            <div id="blackhole-spin-control" class="control-group text-left w-full">
                <label for="spin-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Black Hole Spin:</span>
                    <span id="spin-value">0.00</span>
                </label>
                <input id="spin-slider" type="range" min="0" max="0.99" step="0.01" value="0.0" class="w-full">
            </div>
            <div class="control-group text-left w-full">
                <label for="particle-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Particle Count:</span>
                    <span id="particle-count-value">5000</span>
                </label>
                <input id="particle-slider" type="range" min="100" max="20000" step="100" value="5000" class="w-full">
            </div>
            <div class="control-group text-left w-full">
                <label for="energy-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>System Energy (Temp):</span>
                    <span id="energy-value">1.0x</span>
                </label>
                <input id="energy-slider" type="range" min="0.1" max="5" step="0.1" value="1.0" class="w-full">
            </div>
            <div class="control-group text-left w-full">
                <label for="particle-size-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Particle Size:</span>
                    <span id="particle-size-value">0.10</span>
                </label>
                <input id="particle-size-slider" type="range" min="0.02" max="0.5" step="0.01" value="0.1" class="w-full">
            </div>
              <hr class="border-gray-600">
              <h4 class="text-lg font-bold text-gray-300 text-left w-full">Grid Settings</h4>
              <div class="control-group text-left w-full">
                <label for="grid-color-input" class="text-sm font-medium self-start w-full">Grid Color</label>
                <input id="grid-color-input" type="color" value="#CCCCCC">
            </div>
            <div class="control-group text-left w-full">
                <label for="grid-slice-button" class="text-sm font-medium self-start w-full">Grid View</label>
                <button id="grid-slice-button" class="toggle-button w-full">3D Full</button>
            </div>
            <div id="grid-thickness-control" class="control-group text-left w-full hidden">
                <label for="grid-thickness-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Slice Thickness:</span>
                    <span id="grid-thickness-value">0 layers</span>
                </label>
                <input id="grid-thickness-slider" type="range" min="0" max="5" step="1" value="0" class="w-full">
            </div>
              <div class="control-group text-left w-full">
                <label for="grid-scale-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Grid Scale:</span>
                    <span id="grid-scale-value">1.0x</span>
                </label>
                <input id="grid-scale-slider" type="range" min="0.1" max="1000" step="0.1" value="1.0" class="w-full">
            </div>
            <div class="control-group text-left w-full">
                <label for="grid-lines-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Grid Line Count:</span>
                    <span id="grid-lines-value">15</span>
                </label>
                <input id="grid-lines-slider" type="range" min="5" max="50" step="1" value="15" class="w-full">
            </div>
            <hr class="border-gray-600">
            <div class="control-group text-left w-full">
                <label for="graphics-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Graphics Quality:</span>
                    <span id="graphics-quality-value">High</span>
                </label>
                <input id="graphics-slider" type="range" min="0.5" max="2" step="0.1" value="1.5" class="w-full">
                   <div class="text-xs text-gray-500 w-full flex justify-between mt-1">
                      <span>Low</span>
                      <span>Native</span>
                      <span>High</span>
                   </div>
            </div>
        </div>
    </div>


<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';
    import { XRHandModelFactory } from 'three/examples/jsm/webxr/XRHandModelFactory.js';

    let scene, camera, renderer, controls, raycaster, mouse, clock;
    let playerDolly; // For VR movement
    let controller1, controller2, controllerGrip1, controllerGrip2;
    let hand1, hand2;
    let activeSceneObjects = new THREE.Group();
    let currentParticleSystem = null;
    let particles = [];

    // --- VR Input State Manager ---
    const vrInputs = {
        left: { grip: { pressed: false }, trigger: { pressed: false }, thumbstick: { x: 0, y: 0 } },
        right: { grip: { pressed: false }, trigger: { pressed: false }, thumbstick: { x: 0, y: 0 } },
        isZooming: false,
        initialZoomDistance: 0,
        initialDollyScale: new THREE.Vector3()
    };

    // --- Global Settings ---
    let particleCount = 5000;
    let particleSize = 0.1;
    let systemEnergy = 1.0;
    let timeMultiplier = 999;
    let lightRayRange = 40;
    let followMode = false;
    let isPaused = false;
    let gridColor = '#CCCCCC';
    let gridScale = 1.0;
    let gridLineCount = 15;
    let gridSliceMode = '3d'; // '3d', 'x', 'y', 'z'
    let gridSliceThickness = 0; // In layers
    let blackHoleSpin = 0.0;

    let followObject = null;
    
    // --- Main simulation functions ---
    let currentCleanup = () => {};
    let currentUpdate = () => {};

    function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 4, 15);
        
        // VR Dolly for movement
        playerDolly = new THREE.Group();
        playerDolly.add(camera);
        scene.add(playerDolly);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        renderer.xr.enabled = true;

        scene.add(new THREE.AmbientLight(0xffffff, 0.2));
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 2000);
        pointLight.position.set(0, 50, 50);
        scene.add(pointLight);

        scene.add(activeSceneObjects);

        setupSettingsPanel();
        setupFullscreen();
        setupVR();
        
        // Directly initialize the black hole simulation
        const simulation = initBlackHole();
        currentUpdate = simulation.update;
        currentCleanup = simulation.cleanup;
        followObject = simulation.followTarget;

        window.addEventListener('resize', onWindowResize, false);
        document.getElementById('info-panel').addEventListener('click', (e) => {
            if (e.target.closest('canvas') || e.target.closest('a')) return;
            e.currentTarget.classList.toggle('expanded');
        });

        renderer.setAnimationLoop(animate);
    }

    function resetSimulation() {
        isPaused = false;
        const pauseButton = document.getElementById('pause-toggle');
        if (pauseButton) {
            pauseButton.textContent = 'Pause';
            pauseButton.classList.remove('active');
        }

        // Cleanup old objects
        currentCleanup();
        while(activeSceneObjects.children.length > 0) { 
            const obj = activeSceneObjects.children[0];
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(m => m.dispose());
                } else {
                    obj.material.dispose();
                }
            }
            activeSceneObjects.remove(obj); 
        }
        document.getElementById('controls-panel').innerHTML = '';
        
        // Re-initialize
        const simulation = initBlackHole();
        currentUpdate = simulation.update;
        currentCleanup = simulation.cleanup;
        followObject = simulation.followTarget;
    }


    function setupFullscreen() {
        const fullscreenButton = document.getElementById('fullscreen-button');
        const enterIcon = document.getElementById('fullscreen-enter-icon');
        const exitIcon = document.getElementById('fullscreen-exit-icon');
        const body = document.body;

        if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled) {
            fullscreenButton.style.display = 'none'; // Hide if not supported
            return;
        }

        function openFullscreen() {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if (document.documentElement.webkitRequestFullscreen) { /* Safari */
                document.documentElement.webkitRequestFullscreen();
            }
        }

        function closeFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            }
        }

        fullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                openFullscreen();
            } else {
                closeFullscreen();
            }
        });

        const handleFullscreenChange = () => {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
            enterIcon.classList.toggle('hidden', isFullscreen);
            exitIcon.classList.toggle('hidden', !isFullscreen);
            body.classList.toggle('fullscreen-active', isFullscreen);
            // When exiting fullscreen, remove any lingering hover classes
            if (!isFullscreen) {
                document.querySelectorAll('.show-on-hover').forEach(el => el.classList.remove('show-on-hover'));
            }
            // Add a small delay to allow the browser to report the correct new dimensions before resizing the canvas.
            setTimeout(onWindowResize, 100);
        };

        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);

        // --- Hover Logic for Fullscreen ---
        let hideTimer = null;
        window.addEventListener('mousemove', (e) => {
            if (!body.classList.contains('fullscreen-active')) return;

            const hotzoneHeight = 120; // Active area in pixels from top or bottom

            const isNearTop = e.clientY < hotzoneHeight;
            const isNearBottom = window.innerHeight - e.clientY < hotzoneHeight;
            
            const controlsPanel = document.getElementById('controls-panel');
            const settingsButton = document.getElementById('settings-button');
            const fsButton = document.getElementById('fullscreen-button');

            clearTimeout(hideTimer);

            const showElements = (elements) => elements.forEach(el => el.classList.add('show-on-hover'));
            const hideElements = (elements) => elements.forEach(el => el.classList.remove('show-on-hover'));
            
            if (isNearTop) {
                showElements([settingsButton]);
                hideElements([controlsPanel, fsButton]);
            } else if (isNearBottom) {
                showElements([controlsPanel, fsButton]);
                hideElements([settingsButton]);
            } else {
                hideTimer = setTimeout(() => {
                    hideElements([settingsButton, controlsPanel, fsButton]);
                }, 500);
            }
        });
    }

    function setupVR() {
        const vrButton = document.getElementById('vr-button');

        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                if (supported) {
                    vrButton.addEventListener('click', () => {
                        if (renderer.xr.isPresenting) {
                            const session = renderer.xr.getSession();
                            if (session) session.end();
                        } else {
                            const sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor', 'hand-tracking' ] };
                            navigator.xr.requestSession('immersive-vr', sessionInit).then((session) => {
                                renderer.xr.setSession(session);
                            });
                        }
                    });

                    renderer.xr.addEventListener('sessionstart', () => {
                        // When entering VR, move the dolly to the camera's current position
                        playerDolly.position.copy(camera.position);
                        playerDolly.quaternion.copy(camera.quaternion);
                        camera.position.set(0, 0, 0);
                        camera.quaternion.identity();
                        controls.enabled = false;

                        vrButton.innerHTML = `... Exit VR`;
                        vrButton.classList.add('active');
                    });
                    renderer.xr.addEventListener('sessionend', () => {
                        // When exiting VR, move camera back to dolly's position and reset dolly
                        camera.position.copy(playerDolly.position);
                        camera.scale.copy(playerDolly.scale);
                        playerDolly.position.set(0, 0, 0);
                        playerDolly.quaternion.identity();
                        playerDolly.scale.set(1, 1, 1);
                        controls.enabled = true;

                        vrButton.innerHTML = `... Enter VR`;
                        vrButton.classList.remove('active');
                    });

                } else {
                    vrButton.disabled = true;
                    vrButton.textContent = 'VR Not Supported';
                }
            });
        } else {
             vrButton.disabled = true;
             vrButton.textContent = 'VR Not Supported';
        }

        // --- Controllers & Hands Setup ---
        controller1 = renderer.xr.getController(0);
        playerDolly.add(controller1);

        controller2 = renderer.xr.getController(1);
        playerDolly.add(controller2);

        const controllerModelFactory = new XRControllerModelFactory();
        const handModelFactory = new XRHandModelFactory();

        controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        playerDolly.add(controllerGrip1);

        controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        playerDolly.add(controllerGrip2);

        hand1 = renderer.xr.getHand(0);
        hand1.add(handModelFactory.createHandModel(hand1));
        playerDolly.add(hand1);

        hand2 = renderer.xr.getHand(1);
        hand2.add(handModelFactory.createHandModel(hand2));
        playerDolly.add(hand2);
    }

    function setupSettingsPanel() {
        const settingsPanel = document.getElementById('settings-panel');
        const settingsButton = document.getElementById('settings-button');
        const closeSettingsButton = document.getElementById('close-settings');

        const particleSlider = document.getElementById('particle-slider');
        const particleCountValue = document.getElementById('particle-count-value');
        const graphicsSlider = document.getElementById('graphics-slider');
        const graphicsQualityValue = document.getElementById('graphics-quality-value');
        const energySlider = document.getElementById('energy-slider');
        const energyValue = document.getElementById('energy-value');
        const particleSizeSlider = document.getElementById('particle-size-slider');
        const particleSizeValue = document.getElementById('particle-size-value');
        const lightSpeedSlider = document.getElementById('light-speed-slider');
        const lightSpeedValue = document.getElementById('light-speed-value');
        const traceLengthSlider = document.getElementById('trace-length-slider');
        const traceLengthValue = document.getElementById('trace-length-value');
        const spinSlider = document.getElementById('spin-slider');
        const spinValue = document.getElementById('spin-value');
        const followToggle = document.getElementById('follow-toggle');
        const gridColorInput = document.getElementById('grid-color-input');
        const gridScaleSlider = document.getElementById('grid-scale-slider');
        const gridScaleValue = document.getElementById('grid-scale-value');
        const gridLinesSlider = document.getElementById('grid-lines-slider');
        const gridLinesValue = document.getElementById('grid-lines-value');
        const gridSliceButton = document.getElementById('grid-slice-button');
        const gridThicknessControl = document.getElementById('grid-thickness-control');
        const gridThicknessSlider = document.getElementById('grid-thickness-slider');
        const gridThicknessValue = document.getElementById('grid-thickness-value');
        
        const sliceModes = ['3d', 'x', 'y', 'z'];
        let currentSliceIndex = 0;
        gridSliceButton.addEventListener('click', () => {
            currentSliceIndex = (currentSliceIndex + 1) % sliceModes.length;
            gridSliceMode = sliceModes[currentSliceIndex];
            
            const modeText = {
                '3d': '3D Full', 'x': 'Slice: YZ Plane', 'y': 'Slice: XZ Plane', 'z': 'Slice: XY Plane'
            };
            gridSliceButton.textContent = modeText[gridSliceMode];
            
            const isSlice = gridSliceMode !== '3d';
            gridThicknessControl.classList.toggle('hidden', !isSlice);
        });

        gridThicknessSlider.addEventListener('input', e => {
            gridSliceThickness = parseInt(e.target.value, 10);
            gridThicknessValue.textContent = `${gridSliceThickness} layer${gridSliceThickness === 1 ? '' : 's'}`;
        });

        function toggleSettingsPanel() {
            const isOpen = settingsPanel.classList.contains('open');
            if (isOpen) {
                settingsPanel.classList.remove('open');
            } else {
                settingsPanel.classList.remove('hidden');
                requestAnimationFrame(() => {
                    settingsPanel.classList.add('open');
                });
            }
        }

        settingsButton.addEventListener('click', toggleSettingsPanel);
        closeSettingsButton.addEventListener('click', () => {
            settingsPanel.classList.remove('open');
        });

        settingsPanel.addEventListener('transitionend', (event) => {
            if (event.propertyName !== 'transform') return;
            if (!settingsPanel.classList.contains('open')) {
                settingsPanel.classList.add('hidden');
            }
        });

        const initialPixelRatio = 1.0;
        graphicsSlider.value = initialPixelRatio;
        renderer.setPixelRatio(initialPixelRatio);
        updateGraphicsLabel(initialPixelRatio);

        followToggle.addEventListener('click', (e) => {
            followMode = !followMode;
            e.target.textContent = followMode ? 'On' : 'Off';
            e.target.classList.toggle('active', followMode);
        });
        lightSpeedSlider.addEventListener('input', (e) => {
            timeMultiplier = parseFloat(e.target.value);
            lightSpeedValue.textContent = `${timeMultiplier.toFixed(0)}x`;
        });
        traceLengthSlider.addEventListener('input', (e) => {
            lightRayRange = parseFloat(e.target.value);
            traceLengthValue.textContent = lightRayRange;
        });
        spinSlider.addEventListener('input', (e) => {
            blackHoleSpin = parseFloat(e.target.value);
            spinValue.textContent = blackHoleSpin.toFixed(2);
        });
        particleSlider.addEventListener('input', (e) => particleCountValue.textContent = e.target.value);
        particleSlider.addEventListener('change', (e) => {
            particleCount = parseInt(e.target.value, 10);
            resetSimulation(); 
        });
        energySlider.addEventListener('input', (e) => {
            systemEnergy = parseFloat(e.target.value);
            energyValue.textContent = `${systemEnergy.toFixed(1)}x`;
        });
        particleSizeSlider.addEventListener('input', (e) => {
            particleSize = parseFloat(e.target.value);
            particleSizeValue.textContent = particleSize.toFixed(2);
            if(currentParticleSystem) {
                currentParticleSystem.material.size = particleSize;
            }
        });
        gridColorInput.addEventListener('input', (e) => {
            gridColor = e.target.value;
        });
        gridScaleSlider.addEventListener('input', (e) => {
            gridScale = parseFloat(e.target.value);
            gridScaleValue.textContent = `${gridScale.toFixed(1)}x`;
        });
        gridLinesSlider.addEventListener('input', (e) => {
            gridLinesValue.textContent = e.target.value;
        });
        gridLinesSlider.addEventListener('change', (e) => {
            gridLineCount = parseInt(e.target.value, 10);
            resetSimulation();
        });
        graphicsSlider.addEventListener('input', (e) => {
            const quality = parseFloat(e.target.value);
            renderer.setPixelRatio(quality);
            updateGraphicsLabel(quality);
        });

        function updateGraphicsLabel(quality) {
            if (quality < 0.8) graphicsQualityValue.textContent = "Low";
            else if (quality < 1.5) graphicsQualityValue.textContent = "Medium";
            else if (quality < 1.9) graphicsQualityValue.textContent = "High";
            else graphicsQualityValue.textContent = "Ultra";
        }
    }

    function createParticles(count, color = 0x818cf8) {
        particles = [];
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        const material = new THREE.PointsMaterial({ size: particleSize, blending: THREE.AdditiveBlending, transparent: true, sizeAttenuation: true, vertexColors: true });
        for (let i = 0; i < count; i++) {
            const [x,y,z] = [(Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10];
            positions.set([x,y,z], i*3);
            const baseColor = new THREE.Color(color);
            colors.set([baseColor.r, baseColor.g, baseColor.b], i * 3);
            particles.push({ position: new THREE.Vector3(x, y, z), velocity: new THREE.Vector3(), lastY: y });
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        currentParticleSystem = new THREE.Points(geometry, material);
        activeSceneObjects.add(currentParticleSystem);
        return currentParticleSystem;
    }

    function initBlackHole() {
        const G = 1, c = 10, STAR_THRESHOLD = 3.0;
        let mass = 1.0;
        let time = 0;
        let entropyText, radiusText, kappaText, ratioText, lorentzText;
        let vectorFieldVisible = false;
        let lightRaysVisible = true;
        let geodesicLinesVisible = false;
        let gridVisible = true;
        let particlesVisible = true;

        const GRID_SIZE = 20;
        const GRID_SPACING = 5;
        const SIMULATION_RADIUS = GRID_SIZE * GRID_SPACING;

        // --- Starfield Background ---
        const starVertices = [];
        for (let i = 0; i < 10000; i++) starVertices.push(THREE.MathUtils.randFloatSpread(2000), THREE.MathUtils.randFloatSpread(2000), THREE.MathUtils.randFloatSpread(2000));
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({ color: 0x888888, size: 0.7 }));
        activeSceneObjects.add(stars);

        // --- Central Object (Black Hole or Star) ---
        const centralObject = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshBasicMaterial({ color: 0x000000 }));
        activeSceneObjects.add(centralObject);

        // --- Event Horizon Outline ---
        const horizonOutline = new THREE.Mesh(new THREE.TorusGeometry(1, 0.1, 16, 100), new THREE.MeshBasicMaterial({ color: 0xffa500, side: THREE.DoubleSide }));
        activeSceneObjects.add(horizonOutline);

       // --- Spacetime Vector Field ---
        const vectorField = new THREE.Group();
        const arrows = [];
        for (let x = -GRID_SIZE; x <= GRID_SIZE; x++) {
            for (let y = -GRID_SIZE; y <= GRID_SIZE; y++) {
                for (let z = -GRID_SIZE; z <= GRID_SIZE; z++) {
                    const origin = new THREE.Vector3(x * GRID_SPACING, y * GRID_SPACING, z * GRID_SPACING);
                    if (origin.length() < GRID_SPACING * 1.5 || Math.random() > 0.3) continue; 
                    const arrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), origin, 2, 0x4b5563, 1, 0.5);
                    arrows.push(arrow);
                    vectorField.add(arrow);
                }
            }
        }
        activeSceneObjects.add(vectorField);

        // --- Flowing Particles ---
        const flowingParticles = createParticles(particleCount, 0xffffff);
        flowingParticles.material.size = 0.08;

        // --- Geodesic Lines ---
        const geodesicGroup = new THREE.Group();
        const geodesicLines = [];
        const NUM_GEODESICS = 100;
        const GEO_POINTS = 200;

        for(let i=0; i < NUM_GEODESICS; i++) {
            const material = new THREE.LineBasicMaterial({color: 0x60a5fa, transparent: true, opacity: 0.7, linewidth: 2});
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(GEO_POINTS * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const line = new THREE.Line(geometry, material);

            const startPos = new THREE.Vector3();
            const face = Math.floor(Math.random() * 6);
            const coord = (val) => (Math.random() - 0.5) * 2 * val;
            switch(face) {
               case 0: startPos.set(SIMULATION_RADIUS, coord(SIMULATION_RADIUS), coord(SIMULATION_RADIUS)); break;
               case 1: startPos.set(-SIMULATION_RADIUS, coord(SIMULATION_RADIUS), coord(SIMULATION_RADIUS)); break;
               case 2: startPos.set(coord(SIMULATION_RADIUS), SIMULATION_RADIUS, coord(SIMULATION_RADIUS)); break;
               case 3: startPos.set(coord(SIMULATION_RADIUS), -SIMULATION_RADIUS, coord(SIMULATION_RADIUS)); break;
               case 4: startPos.set(coord(SIMULATION_RADIUS), coord(SIMULATION_RADIUS), SIMULATION_RADIUS); break;
               case 5: startPos.set(coord(SIMULATION_RADIUS), coord(SIMULATION_RADIUS), -SIMULATION_RADIUS); break;
            }

            const vecToCenter = startPos.clone().normalize().multiplyScalar(-1);
            const randomVec = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            const tangentVec = vecToCenter.clone().cross(randomVec).normalize();
            const initialVelocity = tangentVec.multiplyScalar(c * 0.05); 

            geodesicLines.push({line, startPos, initialVelocity});
            geodesicGroup.add(line);
        }
        activeSceneObjects.add(geodesicGroup);

        // --- Static 3D Grid ---
        const staticGridGroup = new THREE.Group();
        staticGridGroup.userData.lines = [];
        const gridLineMaterial = new THREE.LineBasicMaterial({ color: new THREE.Color(gridColor), transparent: true, opacity: 0.5 });
        const gridLineSegments = 50;
        const gridStep = (SIMULATION_RADIUS * 2) / (gridLineCount - 1);

        for (let i = 0; i < gridLineCount; i++) {
            const current = -SIMULATION_RADIUS + i * gridStep;
            // XY plane lines
            for (let j = 0; j < gridLineCount; j++) {
                const z = -SIMULATION_RADIUS + j * gridStep;
                staticGridGroup.userData.lines.push({ start: new THREE.Vector3(-SIMULATION_RADIUS, current, z), end: new THREE.Vector3(SIMULATION_RADIUS, current, z) });
                staticGridGroup.userData.lines.push({ start: new THREE.Vector3(current, -SIMULATION_RADIUS, z), end: new THREE.Vector3(current, SIMULATION_RADIUS, z) });
            }
             // XZ planes
            for (let j = 0; j < gridLineCount; j++) {
                const y = -SIMULATION_RADIUS + j * gridStep;
                staticGridGroup.userData.lines.push({ start: new THREE.Vector3(-SIMULATION_RADIUS, y, current), end: new THREE.Vector3(SIMULATION_RADIUS, y, current) });
                staticGridGroup.userData.lines.push({ start: new THREE.Vector3(current, y, -SIMULATION_RADIUS), end: new THREE.Vector3(current, y, SIMULATION_RADIUS) });
            }
        }

        staticGridGroup.userData.lines.forEach(data => {
            const points = [];
            for(let i=0; i <= gridLineSegments; i++){
                points.push(data.start.clone().lerp(data.end, i/gridLineSegments));
            }
            let geom = new THREE.BufferGeometry().setFromPoints(points);
            data.line = new THREE.Line(geom, gridLineMaterial.clone());
            data.originalVertices = points;
            staticGridGroup.add(data.line);
        });
        activeSceneObjects.add(staticGridGroup);


        const resetParticle = (p) => {
            const gridX = Math.floor(Math.random() * (2 * GRID_SIZE + 1)) - GRID_SIZE;
            const gridY = Math.floor(Math.random() * (2 * GRID_SIZE + 1)) - GRID_SIZE;
            const gridZ = Math.floor(Math.random() * (2 * GRID_SIZE + 1)) - GRID_SIZE;

            const axis = Math.floor(Math.random() * 3);
            const pos = new THREE.Vector3(gridX * GRID_SPACING, gridY * GRID_SPACING, gridZ * GRID_SPACING);

            if(axis === 0) pos.x += (Math.random() - 0.5) * GRID_SPACING;
            else if(axis === 1) pos.y += (Math.random() - 0.5) * GRID_SPACING;
            else pos.z += (Math.random() - 0.5) * GRID_SPACING;

            p.position.copy(pos);
        };
        particles.forEach(resetParticle);


        // --- Light Rays ---
        const lightRayGroup = new THREE.Group();
        const MAX_RAYS = 200, NUM_WAVE_POINTS = 20;
        const rays = [];
        for (let i = 0; i < MAX_RAYS; i++) {
            const material = new THREE.LineBasicMaterial({ vertexColors: true });
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(NUM_WAVE_POINTS * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const line = new THREE.Line(geometry, material);
            lightRayGroup.add(line);
            rays.push({ line, position: new THREE.Vector3(), velocity: new THREE.Vector3(), prevDist: 0 });
        }
        activeSceneObjects.add(lightRayGroup);

        function resetRay(ray) {
            const rs = (2 * G * mass) / (c * c);
            const startRadius = rs * 1.5 + Math.random() * 10;
            ray.position.setFromSphericalCoords(startRadius, Math.acos(2 * Math.random() - 1), Math.random() * Math.PI * 2);
            ray.velocity.copy(ray.position).clone().cross(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5)).normalize().multiplyScalar(c * 0.1);
            ray.prevDist = startRadius;
            const positions = ray.line.geometry.attributes.position.array;
            for(let i = 0; i < positions.length; i+=3) {
                positions[i] = ray.position.x;
                positions[i+1] = ray.position.y;
                positions[i+2] = ray.position.z;
            }
            ray.line.geometry.attributes.position.needsUpdate = true;
        }
        rays.forEach(resetRay);

        function createControls() {
            const controlsDiv = document.getElementById('controls-panel');
            controlsDiv.innerHTML = `
                <div class="control-group">
                      <label class="text-sm font-medium">Mass (10^x Solar Masses): <span id="mass-value">1.00e+0</span></label>
                      <div class="flex items-center gap-2 flex-wrap justify-center">
                          <input id="mass-slider" type="range" min="-2" max="10.6" step="0.05" value="0" class="w-full max-w-[180px]">
                          <button id="particle-toggle" class="toggle-button active text-xs p-2">Particles: On</button>
                          <button id="grid-toggle" class="toggle-button active text-xs p-2">Spacetime Grid: On</button>
                          <button id="vector-field-toggle" class="toggle-button text-xs p-2">Vectors: Off</button>
                          <button id="light-rays-toggle" class="toggle-button active text-xs p-2">Light Rays: On</button>
                          <button id="geodesic-toggle" class="toggle-button text-xs p-2">Geodesics: Off</button>
                      </div>
               </div>
               <div class="flex items-center gap-2 flex-wrap justify-center">
                   <button id="pause-toggle" class="toggle-button text-sm p-2">Pause</button>
                   <button id="reset-button" class="toggle-button text-sm p-2">Reset</button>
               </div>
               <div class="flex flex-wrap gap-x-6 gap-y-2 justify-center">
                   <div class="control-group"> <div class="text-xs text-purple-400">Entropy (S/k<sub>B</sub>)</div> <div id="bh-entropy-value" class="text-lg font-bold">...</div> </div>
                   <div class="control-group"> <div class="text-xs text-purple-400">Object Radius</div> <div id="rs-value" class="text-lg font-bold">...</div> </div>
                   <div class="control-group"> <div class="text-xs text-purple-400">Surface Gravity (κ)</div> <div id="kappa-value" class="text-lg font-bold">...</div> </div>
                   <div class="control-group"> <div class="text-xs text-purple-400">κ / c Ratio</div> <div id="ratio-value" class="text-lg font-bold">...</div> </div>
                   <div class="control-group"> <div class="text-xs text-purple-400">Lorentz Factor (γ) at R<sub>S</sub></div> <div id="lorentz-value" class="text-lg font-bold">...</div> </div>
               </div>
            `;
            entropyText = document.getElementById('bh-entropy-value');
            radiusText = document.getElementById('rs-value');
            kappaText = document.getElementById('kappa-value');
            ratioText = document.getElementById('ratio-value');
            lorentzText = document.getElementById('lorentz-value');
            const massValueSpan = document.getElementById('mass-value');
            const massSlider = document.getElementById('mass-slider');
            const vectorFieldToggle = document.getElementById('vector-field-toggle');
            const lightRaysToggle = document.getElementById('light-rays-toggle');
            const geodesicToggle = document.getElementById('geodesic-toggle');
            const gridToggle = document.getElementById('grid-toggle');
            const particleToggle = document.getElementById('particle-toggle');
            const pauseButton = document.getElementById('pause-toggle');
            const resetButton = document.getElementById('reset-button');


            mass = Math.pow(10, parseFloat(massSlider.value));
            massValueSpan.textContent = mass.toExponential(2);

            massSlider.addEventListener('input', (e) => {
                const logMass = parseFloat(e.target.value);
                mass = Math.pow(10, logMass);
                massValueSpan.textContent = mass.toExponential(2);
            });

            vectorFieldToggle.addEventListener('click', (e) => {
                vectorFieldVisible = !vectorFieldVisible;
                e.target.textContent = `Vectors: ${vectorFieldVisible ? 'On' : 'Off'}`;
                e.target.classList.toggle('active', vectorFieldVisible);
            });

            lightRaysToggle.addEventListener('click', (e) => {
                lightRaysVisible = !lightRaysVisible;
                e.target.textContent = `Light Rays: ${lightRaysVisible ? 'On' : 'Off'}`;
                e.target.classList.toggle('active', lightRaysVisible);
            });

            geodesicToggle.addEventListener('click', (e) => {
                geodesicLinesVisible = !geodesicLinesVisible;
                e.target.textContent = `Geodesics: ${geodesicLinesVisible ? 'On' : 'Off'}`;
                e.target.classList.toggle('active', geodesicLinesVisible);
            });

            gridToggle.addEventListener('click', (e) => {
                gridVisible = !gridVisible;
                e.target.textContent = `Spacetime Grid: ${gridVisible ? 'On' : 'Off'}`;
                e.target.classList.toggle('active', gridVisible);
            });
             particleToggle.addEventListener('click', (e) => {
                particlesVisible = !particlesVisible;
                e.target.textContent = `Particles: ${particlesVisible ? 'On' : 'Off'}`;
                e.target.classList.toggle('active', particlesVisible);
            });

            pauseButton.addEventListener('click', (e) => {
                isPaused = !isPaused;
                e.target.textContent = isPaused ? 'Resume' : 'Pause';
                e.target.classList.toggle('active', isPaused);
            });

            resetButton.addEventListener('click', () => {
                resetSimulation();
            });
        }

        function update(delta) {
            if (isPaused) return;

            const dt = 0.016 * timeMultiplier;
            time += dt;

            const isBlackHole = mass >= STAR_THRESHOLD;
            const M_geom = (G * mass) / (c * c);
            const a = blackHoleSpin * M_geom; // Spin parameter
            
            let rs, objectRadius;

            if (a > M_geom) { // Naked singularity, not physically expected
                rs = 0;
                objectRadius = 0.1; // small placeholder
            } else {
                rs = M_geom + Math.sqrt(M_geom * M_geom - a * a); // Outer event horizon
                objectRadius = isBlackHole ? rs : Math.pow(mass, 1/3) * 0.5;
            }


            centralObject.scale.setScalar(objectRadius);
            horizonOutline.scale.setScalar(rs);
            horizonOutline.visible = isBlackHole;
            centralObject.material.color.set(isBlackHole ? 0x000000 : 0xffffdd);

            const A = 4 * Math.PI * (rs * rs + a * a);
            const kappa_num = Math.sqrt(M_geom * M_geom - a * a);
            const kappa_den = 2 * M_geom * (M_geom + Math.sqrt(M_geom * M_geom - a * a)) - 2*a*a;
            const kappa = kappa_den > 1e-9 ? (c**4 / (G)) * (kappa_num / kappa_den) : 0;

            entropyText.textContent = (A / 4).toExponential(2);
            radiusText.textContent = objectRadius.toFixed(2);
            kappaText.textContent = isFinite(kappa) ? kappa.toExponential(2) : 'N/A';
            ratioText.textContent = isFinite(kappa) ? (kappa / c).toExponential(2) : 'N/A';
            lorentzText.innerHTML = "&infin;";

            const spinAxis = new THREE.Vector3(0, 1, 0);

            vectorField.visible = vectorFieldVisible;
            if (vectorFieldVisible) {
                arrows.forEach(arrow => {
                    const r = arrow.position.length();
                    if (r > 0.01) {
                        const v_inflow_mag = Math.sqrt(rs / r) * c;
                        const inflow_direction = arrow.position.clone().normalize().multiplyScalar(-1);
                        arrow.setDirection(inflow_direction);
                        arrow.setLength(Math.min(v_inflow_mag * 0.5, GRID_SPACING * 0.9), 0.5, 0.2);
                    }
                });
            }

            flowingParticles.visible = particlesVisible;
            if (particlesVisible) {
                const particlePositions = flowingParticles.geometry.attributes.position;
                particles.forEach((p, i) => {
                    const r = p.position.length();
                    if (r > 0.01) {
                        const v_inflow_mag = Math.sqrt(rs / r) * c;
                        const inflow_velocity = p.position.clone().normalize().multiplyScalar(-v_inflow_mag);
                        
                        const frameDragTerm = (2 * G * mass * a) / (r * r * r * c);
                        const tangentDir = spinAxis.clone().cross(p.position).normalize();
                        const frameDragVel = tangentDir.multiplyScalar(frameDragTerm * systemEnergy * 10);
                        inflow_velocity.add(frameDragVel);

                        p.position.add(inflow_velocity.multiplyScalar(dt * 0.2 * systemEnergy));
                    }

                    if (p.position.length() < objectRadius * 1.1) {
                        resetParticle(p);
                    }
                    particlePositions.setXYZ(i, p.position.x, p.position.y, p.position.z);
                });
                particlePositions.needsUpdate = true;
            }

            geodesicGroup.visible = geodesicLinesVisible;
            if (geodesicLinesVisible) {
                geodesicLines.forEach(item => {
                    const positions = item.line.geometry.attributes.position;
                    let currentPos = item.startPos.clone();
                    let currentVel = item.initialVelocity.clone();
                    const sim_dt = 0.2; 

                    for (let i = 0; i < GEO_POINTS; i++) {
                        positions.setXYZ(i, currentPos.x, currentPos.y, currentPos.z);

                        const r = currentPos.length();
                        if (r < objectRadius * 1.05) {
                            for (let j = i; j < GEO_POINTS; j++) positions.setXYZ(j, currentPos.x, currentPos.y, currentPos.z);
                            break;
                        }

                        const gravitationalForce = -G * mass / (r * r);
                        const acceleration = currentPos.clone().normalize().multiplyScalar(gravitationalForce);

                        const v_inflow_mag = Math.sqrt(rs / r) * c;
                        const inflow_velocity = currentPos.clone().normalize().multiplyScalar(-v_inflow_mag);

                        const frameDragTerm = (2 * G * mass * a) / (r * r * r * c);
                        const tangentDir = spinAxis.clone().cross(currentPos).normalize();
                        const frameDragVel = tangentDir.multiplyScalar(frameDragTerm * 1000);
                        currentVel.add(frameDragVel);

                        currentVel.add(acceleration.multiplyScalar(sim_dt));

                        const posChangeFromVel = currentVel.clone().multiplyScalar(sim_dt);
                        const posChangeFromInflow = inflow_velocity.multiplyScalar(sim_dt * 0.5); 

                        currentPos.add(posChangeFromVel).add(posChangeFromInflow);
                    }
                    positions.needsUpdate = true;
                });
            }
             staticGridGroup.visible = gridVisible;
            if (gridVisible) {
                const step = (SIMULATION_RADIUS * 2) / (gridLineCount - 1);
                const tolerance = gridSliceThickness * step;

                staticGridGroup.userData.lines.forEach(item => {
                    let isVisible = false;
                    const s = item.start;
                    const e = item.end;
                    
                    switch (gridSliceMode) {
                        case '3d': isVisible = true; break;
                        case 'x': 
                            if (s.x === e.x && s.z === e.z && Math.abs(s.x) <= tolerance) isVisible = true;
                            if (s.x === e.x && s.y === e.y && Math.abs(s.x) <= tolerance) isVisible = true;
                            break;
                        case 'y':
                            if (s.y === e.y && s.z === e.z && Math.abs(s.y) <= tolerance) isVisible = true;
                            if (s.x === e.x && s.y === e.y && Math.abs(s.y) <= tolerance) isVisible = true;
                            break;
                        case 'z':
                            if (s.y === e.y && s.z === e.z && Math.abs(s.z) <= tolerance) isVisible = true;
                            if (s.x === e.x && s.z === e.z && Math.abs(s.z) <= tolerance) isVisible = true;
                            break;
                    }
                    item.line.visible = isVisible;
                });

                  staticGridGroup.scale.set(gridScale, gridScale, gridScale);
                  staticGridGroup.userData.lines.forEach(item => {
                      if (!item.line.visible) return;

                      item.line.material.color.set(gridColor);
                      const positions = item.line.geometry.attributes.position;
                      for (let i = 0; i <= gridLineSegments; i++) {
                          let currentPos = item.originalVertices[i].clone();
                          let r = currentPos.length() * gridScale;

                          if (r > 0.01) {
                              const v_inflow_mag = Math.sqrt(rs / r) * c;
                              const inflow_velocity = currentPos.clone().normalize().multiplyScalar(-v_inflow_mag);

                              const frameDragTerm = (2 * G * mass * a) / (r * r * r * c);
                              const tangentDir = spinAxis.clone().cross(currentPos).normalize();
                              const frameDragVel = tangentDir.multiplyScalar(frameDragTerm * time * 50);
                              inflow_velocity.add(frameDragVel);

                              currentPos.add(inflow_velocity.multiplyScalar(time * 0.05));
                          }
                           if(currentPos.length() * gridScale < objectRadius * 1.1) {
                               currentPos.copy(item.originalVertices[i]);
                          }

                          positions.setXYZ(i, currentPos.x, currentPos.y, currentPos.z);
                      }
                      positions.needsUpdate = true;
                  });
            }

            lightRayGroup.visible = lightRaysVisible;
            if(lightRaysVisible) {
                rays.forEach((ray) => {
                    const r = ray.position.length();
                    if(r < objectRadius || r > lightRayRange) {
                        resetRay(ray);
                    }

                    const gravitationalForce = -G * mass / (r * r);
                    const acceleration = ray.position.clone().normalize().multiplyScalar(gravitationalForce);
                    
                    const frameDragTerm = (2 * G * mass * a) / (r * r * r * c);
                    const tangentDir = spinAxis.clone().cross(ray.position).normalize();
                    const frameDragVel = tangentDir.multiplyScalar(frameDragTerm * 100);
                    acceleration.add(frameDragVel);
                    
                    ray.velocity.add(acceleration.multiplyScalar(dt * 20));
                    ray.position.add(ray.velocity.clone().multiplyScalar(dt * 20));

                    const positions = ray.line.geometry.attributes.position;
                    const direction = ray.velocity.clone().normalize();
                    let side = direction.clone().cross(new THREE.Vector3(0, 1, 0));
                    if (side.lengthSq() < 0.001) side.cross(new THREE.Vector3(1, 0, 0));
                    side.normalize();

                    const amplitude = 0.2 / (timeMultiplier + 0.5);
                    const wavePhase = time * 20;

                    for (let i = 0; i < NUM_WAVE_POINTS; i++) {
                        const pointOnLine = ray.position.clone().add(direction.clone().multiplyScalar(-i * 0.2));
                        const offset = side.clone().multiplyScalar(amplitude * Math.sin(i * 2 + wavePhase));
                        pointOnLine.add(offset);
                        positions.setXYZ(i, pointOnLine.x, pointOnLine.y, pointOnLine.z);
                    }

                    const newDist = ray.position.length();
                    let hue = newDist < ray.prevDist ? 0.66 : 0; 
                    if (newDist >= ray.prevDist) {
                        const redshiftFactor = Math.max(0, 1 - (rs*1.5 / r));
                        hue = 0.16 * redshiftFactor;
                    }
                    ray.prevDist = newDist;

                    const color = new THREE.Color();
                    const colors = ray.line.geometry.attributes.color || new THREE.BufferAttribute(new Float32Array(NUM_WAVE_POINTS * 3), 3);
                    for(let i = 0; i < NUM_WAVE_POINTS; i++){
                        const fade = 1.0 - (i / NUM_WAVE_POINTS);
                        color.setHSL(hue, 1.0, 0.5 * fade);
                        colors.setXYZ(i, color.r, color.g, color.b);
                    }
                    ray.line.geometry.setAttribute('color', colors);
                    positions.needsUpdate = true;
                    if(ray.line.geometry.attributes.color) ray.line.geometry.attributes.color.needsUpdate = true;
                });
            }
        }

        createControls();
        return { update, cleanup: () => {}, followTarget: centralObject };
    }
    
    function onWindowResize() { 
        camera.aspect = window.innerWidth / window.innerHeight; 
        camera.updateProjectionMatrix(); 
        renderer.setSize(window.innerWidth, window.innerHeight); 
    }

    function updateCameraFollow() {
        if(followMode && followObject) {
            const targetSize = followObject.scale.x;
            const distance = targetSize * 10 + 25;

            const offset = controls.target.clone().sub(camera.position).normalize().multiplyScalar(distance);
            const targetPosition = followObject.position.clone().sub(offset);
            
            const targetContainer = renderer.xr.isPresenting ? playerDolly : camera;
            targetContainer.position.lerp(targetPosition, 0.1);
            
            if (!renderer.xr.isPresenting) {
                controls.target.lerp(followObject.position, 0.1);
            }
        }
    }

    function updateVRInputs() {
        if (!renderer.xr.isPresenting) return;
        const deadzone = 0.15;
        const updateControllerState = (controller, state) => {
            if (controller && controller.gamepad) {
                const gamepad = controller.gamepad;
                state.trigger.pressed = gamepad.buttons[0] && gamepad.buttons[0].pressed;
                state.grip.pressed = gamepad.buttons[1] && gamepad.buttons[1].pressed;
                state.thumbstick.x = Math.abs(gamepad.axes[2]) > deadzone ? gamepad.axes[2] : 0;
                state.thumbstick.y = Math.abs(gamepad.axes[3]) > deadzone ? gamepad.axes[3] : 0;
            }
        };
        updateControllerState(controller1, vrInputs.left);
        updateControllerState(controller2, vrInputs.right);
    }

    function handleVRControllers(delta) {
        if (renderer.xr.isPresenting) {
            const speed = 3.0;
            const turnSpeed = 1.5;
            
            const cameraDirection = new THREE.Quaternion();
            camera.getWorldQuaternion(cameraDirection);

            const moveDirection = new THREE.Vector3(vrInputs.left.thumbstick.x, 0, vrInputs.left.thumbstick.y);
            if (moveDirection.length() > 0.1) {
                moveDirection.normalize().multiplyScalar(speed * delta);
                const flatCameraQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), new THREE.Euler().setFromQuaternion(cameraDirection).y);
                moveDirection.applyQuaternion(flatCameraQuaternion);
                playerDolly.position.add(moveDirection);
            }

            if (Math.abs(vrInputs.right.thumbstick.x) > 0.1) {
                playerDolly.rotation.y -= vrInputs.right.thumbstick.x * turnSpeed * delta;
            }
             if (Math.abs(vrInputs.right.thumbstick.y) > 0.1) {
                playerDolly.position.y -= vrInputs.right.thumbstick.y * speed * delta;
            }

            const bothGripsPressed = vrInputs.left.grip.pressed && vrInputs.right.grip.pressed;
            if (bothGripsPressed && !vrInputs.isZooming) {
                vrInputs.isZooming = true;
                vrInputs.initialZoomDistance = controllerGrip1.position.distanceTo(controllerGrip2.position);
                vrInputs.initialDollyScale.copy(playerDolly.scale);
            } else if (bothGripsPressed && vrInputs.isZooming) {
                const currentDistance = controllerGrip1.position.distanceTo(controllerGrip2.position);
                if (vrInputs.initialZoomDistance > 0.01) {
                    const scaleFactor = currentDistance / vrInputs.initialZoomDistance;
                    const newScale = vrInputs.initialDollyScale.clone().multiplyScalar(scaleFactor);
                    newScale.clampScalar(0.1, 10.0);
                    playerDolly.scale.copy(newScale);
                }
            } else if (!bothGripsPressed && vrInputs.isZooming) {
                vrInputs.isZooming = false;
            }
        }
    }

    function animate() { 
        const delta = clock.getDelta();
        
        updateVRInputs();

        if (!renderer.xr.isPresenting) {
            controls.update(); 
        }
        
        if(!isPaused && currentUpdate) currentUpdate(delta); 
        
        handleVRControllers(delta);
        updateCameraFollow();
        renderer.render(scene, camera); 
    }
    
    init();
</script>
</body>
</html>
