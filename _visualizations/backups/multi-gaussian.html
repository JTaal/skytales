<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multidimensional Normal Distributions</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0KOVEMmg9rtab2JJv5tnGDxI3JEoqwCIlC5LhJSmbmyLGhEzOTUAP" crossorigin="anonymous">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e5e7eb;
            overflow: hidden;
        }
        #container, #labels, #svg-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #container {
             pointer-events: auto;
        }
        #labels {
            z-index: 2;
        }
        #svg-overlay {
            z-index: 19; /* Below formula, above everything else */
        }
        .label {
            color: #9ca3af;
            font-size: 12px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        }
        #ui-panel {
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(55, 65, 81, 0.5);
            z-index: 10;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        .katex {
             font-size: 0.9em;
        }
        #formula-1d .katex {
            font-size: 1.2em;
        }
        #formula-container {
            position: absolute;
            z-index: 20;
            pointer-events: none;
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(55, 65, 81, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transform: translate(-50%, -100%);
            transition: opacity 0.2s ease-in-out;
        }
         #mode-selector .mode-btn {
             background-color: rgba(17, 24, 39, 0.8);
             backdrop-filter: blur(10px);
             border: 1px solid rgba(55, 65, 81, 0.5);
        }
         #mode-selector .mode-btn.bg-blue-600 {
             border-color: rgba(59, 130, 246, 0.5);
        }
        .cov-matrix {
            font-family: 'Fira Code', monospace;
            border-left: 2px solid #6b7280;
            border-right: 2px solid #6b7280;
            padding: 0 8px;
        }
        .cov-matrix-popup {
            background-color: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(55, 65, 81, 0.7);
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Fira+Code&display=swap" rel="stylesheet">
</head>
<body class="m-0 p-0">
    <div id="container"></div>
    <div id="labels"></div>
    <svg id="svg-overlay" class="hidden"><line id="connector-line" stroke="#6b7280" stroke-width="1.5" stroke-dasharray="4 2"/></svg>

    <div class="absolute top-4 left-1/2 -translate-x-1/2 z-10 text-center w-full max-w-3xl">
        <h1 class="text-xl font-bold text-gray-100" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.7);">Multivariate Gaussian</h1>
    </div>

    <div id="formula-container" class="hidden">
        <div id="formula-1d" class="hidden"><span>$$f(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^2}$$</span></div>
        <div id="formula-2d" class="hidden"><span>$$f(\mathbf{x}) = \frac{1}{2\pi \sqrt{\det(\mathbf{\Sigma})}} \exp\left(-\frac{1}{2}(\mathbf{x}-\mathbf{\mu})^\mathrm{T}\mathbf{\Sigma}^{-1}(\mathbf{x}-\mathbf{\mu})\right)$$</span></div>
        <div id="formula-3d" class="hidden"><span>$$f(\mathbf{x}) = \frac{1}{(2\pi)^{3/2} \sqrt{\det(\mathbf{\Sigma})}} \exp\left(-\frac{1}{2}(\mathbf{x}-\mathbf{\mu})^\mathrm{T}\mathbf{\Sigma}^{-1}(\mathbf{x}-\mathbf{\mu})\right)$$</span></div>
    </div>
    
    <div class="absolute top-12 left-1/2 -translate-x-1/2 z-10 flex justify-center w-full max-w-3xl mt-2">
        <div id="mode-selector" class="flex gap-2 justify-center">
            <button data-mode="1d" class="mode-btn px-4 py-2 text-sm font-medium text-gray-300 rounded-md hover:bg-gray-700 transition-colors">1D Normal</button>
            <button data-mode="2d" class="mode-btn px-4 py-2 text-sm font-medium text-gray-300 rounded-md hover:bg-gray-700 transition-colors">2D Bivariate</button>
            <button data-mode="3d" class="mode-btn px-4 py-2 text-sm font-medium text-gray-300 rounded-md hover:bg-gray-700 transition-colors">3D Trivariate</button>
        </div>
    </div>

    <div id="animation-controls-container" class="absolute top-24 left-1/2 -translate-x-1/2 z-10 flex justify-center w-full max-w-xl mt-2 gap-2 hidden">
        <button id="convolve-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 text-sm">Convolve</button>
    </div>
    
    <!-- <div id="covariance-button-container" class="absolute bottom-24 right-4 z-10">
        <div id="cov-btn-2d" class="relative hidden">
            <button id="toggle-cov-matrix-2d" class="font-mono text-xl p-2 rounded-md transition-colors bg-pink-600 hover:bg-pink-700 text-white">&Sigma;</button>
            <div id="cov-matrix-popup-2d" class="hidden cov-matrix-popup absolute bottom-full right-0 mb-2 p-2 rounded-md">
                 <div class="cov-matrix grid grid-cols-2 gap-x-4 text-center text-green-400">
                    <span id="cov-2d-00">1.00</span><span id="cov-2d-01">0.00</span>
                    <span id="cov-2d-10">0.00</span><span id="cov-2d-11">1.00</span>
                 </div>
            </div>
        </div>
         <div id="cov-btn-3d" class="relative hidden">
            <button id="toggle-cov-matrix-3d" class="font-mono text-xl p-2 rounded-md transition-colors bg-pink-600 hover:bg-pink-700 text-white">&Sigma;</button>
            <div id="cov-matrix-popup-3d" class="hidden cov-matrix-popup absolute bottom-full right-0 mb-2 p-2 rounded-md">
                <div class="cov-matrix grid grid-cols-3 gap-x-3 text-center text-green-400 text-sm">
                    <span id="cov-3d-00">1.00</span><span id="cov-3d-01">0.00</span><span id="cov-3d-02">0.00</span>
                    <span id="cov-3d-10">0.00</span><span id="cov-3d-11">1.00</span><span id="cov-3d-12">0.00</span>
                    <span id="cov-3d-20">0.00</span><span id="cov-3d-21">0.00</span><span id="cov-3d-22">1.00</span>
                </div>
            </div>
        </div>
    </div> -->

    <div id="ui-panel" class="absolute bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-lg shadow-2xl max-w-5xl w-full">
        <!-- 1D Controls -->
        <div id="controls-1d" class="hidden">
            <div class="flex items-center justify-between gap-6">
                <div class="grid grid-cols-2 gap-x-6 gap-y-2 flex-grow">
                    <div>
                        <label for="mean" class="block text-sm font-medium text-gray-300">&mu;: <span id="meanValue" class="font-bold text-blue-400">0.0</span></label>
                        <input id="mean" type="range" min="-5" max="5" step="0.1" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                    </div>
                    <div>
                        <label for="stdDev" class="block text-sm font-medium text-gray-300">&sigma;: <span id="stdDevValue" class="font-bold text-blue-400">1.0</span></label>
                        <input id="stdDev" type="range" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                    </div>
                </div>
                <button id="generateData1D" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-5 rounded-lg transition duration-300 text-base">Generate</button>
            </div>
        </div>
        
        <!-- 2D Controls -->
        <div id="controls-2d" class="hidden">
             <div class="flex items-center justify-between gap-6">
                 <div class="grid grid-cols-3 gap-x-6 gap-y-2 flex-grow">
                     <div>
                         <label for="stdDevX2D" class="block text-sm font-medium text-gray-300">&sigma;<sub>x</sub>: <span id="stdDevXValue2D" class="font-bold text-blue-400">1.0</span></label>
                         <input id="stdDevX2D" type="range" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                     </div>
                     <div>
                         <label for="stdDevZ2D" class="block text-sm font-medium text-gray-300">&sigma;<sub>z</sub>: <span id="stdDevZValue2D" class="font-bold text-blue-400">1.0</span></label>
                         <input id="stdDevZ2D" type="range" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                     </div>
                     <div>
                         <label for="correlation2D" class="block text-sm font-medium text-gray-300">&rho;<sub>xz</sub>: <span id="correlationValue2D" class="font-bold text-blue-400">0.0</span></label>
                         <input id="correlation2D" type="range" min="-0.99" max="0.99" step="0.01" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                     </div>
                 </div>
                 <div class="flex items-center gap-4">
                    <p id="covarianceOutput2D" class="text-center font-mono text-green-400">Cov(X,Z) = 0.00</p>
                    <div id="cov-btn-2d" class="relative">
                        <button id="toggle-cov-matrix-2d" class="font-mono text-xl p-2 rounded-md transition-colors bg-pink-600 hover:bg-pink-700 text-white">&Sigma;</button>
                        <div id="cov-matrix-popup-2d" class="hidden cov-matrix-popup absolute bottom-full right-0 mb-2 p-2 rounded-md">
                             <div class="cov-matrix grid grid-cols-2 gap-x-4 text-center text-green-400">
                                <span id="cov-2d-00">1.00</span><span id="cov-2d-01">0.00</span>
                                <span id="cov-2d-10">0.00</span><span id="cov-2d-11">1.00</span>
                             </div>
                        </div>
                    </div>
                    <button id="generateData2D" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-5 rounded-lg transition duration-300 text-base">Generate</button>
                 </div>
             </div>
        </div>

        <!-- 3D Controls -->
        <div id="controls-3d" class="hidden">
             <div class="flex items-start justify-between gap-4">
                 <div class="grid grid-cols-3 gap-x-4 gap-y-2 flex-grow">
                     <div>
                         <label for="stdDevX3D" class="block text-sm font-medium text-gray-300">&sigma;<sub>x</sub>: <span id="stdDevXValue3D" class="font-bold text-blue-400">1.0</span></label>
                         <input id="stdDevX3D" type="range" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                     </div>
                     <div>
                         <label for="stdDevY3D" class="block text-sm font-medium text-gray-300">&sigma;<sub>y</sub>: <span id="stdDevYValue3D" class="font-bold text-blue-400">1.0</span></label>
                         <input id="stdDevY3D" type="range" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                     </div>
                      <div>
                         <label for="stdDevZ3D" class="block text-sm font-medium text-gray-300">&sigma;<sub>z</sub>: <span id="stdDevZValue3D" class="font-bold text-blue-400">1.0</span></label>
                         <input id="stdDevZ3D" type="range" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                     </div>
                     <div>
                         <label for="rhoXY" class="block text-sm font-medium text-gray-300">&rho;<sub>xy</sub>: <span id="rhoXYValue" class="font-bold text-blue-400">0.0</span></label>
                         <input id="rhoXY" type="range" min="-0.9" max="0.9" step="0.01" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                     </div>
                     <div>
                         <label for="rhoXZ" class="block text-sm font-medium text-gray-300">&rho;<sub>xz</sub>: <span id="rhoXZValue" class="font-bold text-blue-400">0.0</span></label>
                         <input id="rhoXZ" type="range" min="-0.9" max="0.9" step="0.01" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                     </div>
                     <div>
                         <label for="rhoYZ" class="block text-sm font-medium text-gray-300">&rho;<sub>yz</sub>: <span id="rhoYZValue" class="font-bold text-blue-400">0.0</span></label>
                         <input id="rhoYZ" type="range" min="-0.9" max="0.9" step="0.01" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider">
                     </div>
                     <div id="error-message-3d" class="text-red-500 text-xs text-center hidden col-span-3 pt-1">Invalid correlation matrix. The combination of &rho; values is not possible.</div>
                 </div>
                 <div class="flex items-center gap-4 self-center">
                    <div id="cov-btn-3d" class="relative">
                        <button id="toggle-cov-matrix-3d" class="font-mono text-xl p-2 rounded-md transition-colors bg-pink-600 hover:bg-pink-700 text-white">&Sigma;</button>
                        <div id="cov-matrix-popup-3d" class="hidden cov-matrix-popup absolute bottom-full right-0 mb-2 p-2 rounded-md">
                            <div class="cov-matrix grid grid-cols-3 gap-x-3 text-center text-green-400 text-sm">
                                <span id="cov-3d-00">1.00</span><span id="cov-3d-01">0.00</span><span id="cov-3d-02">0.00</span>
                                <span id="cov-3d-10">0.00</span><span id="cov-3d-11">1.00</span><span id="cov-3d-12">0.00</span>
                                <span id="cov-3d-20">0.00</span><span id="cov-3d-21">0.00</span><span id="cov-3d-22">1.00</span>
                            </div>
                        </div>
                    </div>
                    <button id="generateData3D" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-5 rounded-lg transition duration-300 text-base">Generate</button>
                 </div>
             </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0i8" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" xintegrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        let scene, camera, renderer, controls, labelRenderer, raycaster;
        const clock = new THREE.Clock();
        const visualizationGroup = new THREE.Group();
        const pdfGroup = new THREE.Group();
        const guidesGroup = new THREE.Group();
        const NUM_POINTS = 20000;
        const HISTOGRAM_BINS = 40;
        const PLANE_SIZE = 40;
        let currentMode = '';
        let peakPosition = new THREE.Vector3();
        let maxHistHeight = 5;
        let surfaceMaterialToAnimate = null;
        let animationStartTime = 0;
        let covarianceMatrixObject = null;
        let isConvolving = false;
        let convolveStartTime = 0;
        let sweepGroupX = null;
        let sweepGroupZ = null;
        let convolveSurface = null;
        let revealPhase = 'none'; // 'sweeping', 'surface', 'points', 'ellipse'
        let revealStartTime = 0;
        let pointsToReveal = null;
        let ellipseToReveal = null;

        // --- UI Elements ---
        const modeButtons = document.querySelectorAll('.mode-btn');
        const formulaContainer = document.getElementById('formula-container');
        const svgOverlay = document.getElementById('svg-overlay');
        const connectorLine = document.getElementById('connector-line');

        const controls1D = document.getElementById('controls-1d');
        const controls2D = document.getElementById('controls-2d');
        const controls3D = document.getElementById('controls-3d');
        const formula1D = document.getElementById('formula-1d');
        const formula2D = document.getElementById('formula-2d');
        const formula3D = document.getElementById('formula-3d');
        const meanSlider = document.getElementById('mean');
        const stdDevSlider = document.getElementById('stdDev');
        const generateButton1D = document.getElementById('generateData1D');
        const meanValue = document.getElementById('meanValue');
        const stdDevValue = document.getElementById('stdDevValue');
        const stdDevXSlider2D = document.getElementById('stdDevX2D');
        const stdDevZSlider2D = document.getElementById('stdDevZ2D');
        const correlationSlider2D = document.getElementById('correlation2D');
        const generateButton2D = document.getElementById('generateData2D');
        const stdDevXValue2D = document.getElementById('stdDevXValue2D');
        const stdDevZValue2D = document.getElementById('stdDevZValue2D');
        const correlationValue2D = document.getElementById('correlationValue2D');
        const covarianceOutput2D = document.getElementById('covarianceOutput2D');
        const stdDevXSlider3D = document.getElementById('stdDevX3D');
        const stdDevYSlider3D = document.getElementById('stdDevY3D');
        const stdDevZSlider3D = document.getElementById('stdDevZ3D');
        const rhoXYSlider = document.getElementById('rhoXY');
        const rhoXZSlider = document.getElementById('rhoXZ');
        const rhoYZSlider = document.getElementById('rhoYZ');
        const generateButton3D = document.getElementById('generateData3D');
        const stdDevXValue3D = document.getElementById('stdDevXValue3D');
        const stdDevYValue3D = document.getElementById('stdDevYValue3D');
        const stdDevZValue3D = document.getElementById('stdDevZValue3D');
        const rhoXYValue = document.getElementById('rhoXYValue');
        const rhoXZValue = document.getElementById('rhoXZValue');
        const rhoYZValue = document.getElementById('rhoYZValue');
        const toggleCov2D = document.getElementById('toggle-cov-matrix-2d');
        const popupCov2D = document.getElementById('cov-matrix-popup-2d');
        const toggleCov3D = document.getElementById('toggle-cov-matrix-3d');
        const popupCov3D = document.getElementById('cov-matrix-popup-3d');
        const covBtn2D = document.getElementById('cov-btn-2d');
        const covBtn3D = document.getElementById('cov-btn-3d');
        const convolveBtn = document.getElementById('convolve-btn');
        const animationControlsContainer = document.getElementById('animation-controls-container');


        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('labels').appendChild(labelRenderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            raycaster = new THREE.Raycaster();
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            scene.add(guidesGroup);
            visualizationGroup.add(pdfGroup);
            scene.add(visualizationGroup);
            setupEventListeners();
            switchMode('2d');
            animate();
        }
        
        function setupEventListeners() {
            modeButtons.forEach(btn => btn.addEventListener('click', () => switchMode(btn.dataset.mode)));
            [meanSlider, stdDevSlider].forEach(s => {
                s.addEventListener('input', update1DSliderText);
                s.addEventListener('change', update1DDistribution);
            });
            generateButton1D.addEventListener('click', update1DDistribution);
            [stdDevXSlider2D, stdDevZSlider2D, correlationSlider2D].forEach(s => {
                s.addEventListener('input', update2DSliderText);
                s.addEventListener('change', update2DDistribution);
            });
            generateButton2D.addEventListener('click', update2DDistribution);
            [stdDevXSlider3D, stdDevYSlider3D, stdDevZSlider3D, rhoXYSlider, rhoXZSlider, rhoYZSlider].forEach(s => {
                s.addEventListener('input', () => {
                    update3DSliderText();
                    validate3DCorrelation();
                });
                s.addEventListener('change', update3DDistribution);
            });
            generateButton3D.addEventListener('click', update3DDistribution);
            
            toggleCov2D.addEventListener('click', () => toggleCovarianceMatrix('2d'));
            toggleCov3D.addEventListener('click', () => toggleCovarianceMatrix('3d'));
            convolveBtn.addEventListener('click', startConvolveAnimation);

            window.addEventListener('resize', onWindowResize);

            // remove lateron
            window.visualizationGroup = visualizationGroup;

            renderer.domElement.addEventListener('pointerdown', onCanvasClick);
        }

        function toggleCovarianceMatrix(mode) {
            const isMobile = window.innerWidth < 768;
            const popup = document.getElementById(`cov-matrix-popup-${mode}`);
            
            if (covarianceMatrixObject) {
                guidesGroup.remove(covarianceMatrixObject);
                covarianceMatrixObject = null;
                 return; // If object exists, just remove it and stop
            }

            const otherMode = mode === '2d' ? '3d' : '2d';
            document.getElementById(`cov-matrix-popup-${otherMode}`).classList.add('hidden');

            const matrixContainer = document.createElement('div');
            matrixContainer.innerHTML = popup.innerHTML;
            matrixContainer.className = "cov-matrix-popup p-2 rounded-md";
            
            covarianceMatrixObject = new CSS2DObject(matrixContainer);
            const halfSize = PLANE_SIZE/2;

            if (mode === '2d') {
                covarianceMatrixObject.position.set(halfSize * 0.5, 4, halfSize * 0.5);
            } else { // 3d
                covarianceMatrixObject.position.set(halfSize * 0.6, halfSize * 0.6, 0);
            }
            guidesGroup.add(covarianceMatrixObject);

        }
        
        function switchMode(newMode) {
            if (currentMode === newMode) return;
            currentMode = newMode;
            modeButtons.forEach(btn => {
                btn.classList.toggle('bg-blue-600', btn.dataset.mode === newMode);
                btn.classList.toggle('text-white', btn.dataset.mode === newMode);
            });
            controls1D.classList.toggle('hidden', newMode !== '1d');
            controls2D.classList.toggle('hidden', newMode !== '2d');
            controls3D.classList.toggle('hidden', newMode !== '3d');
            animationControlsContainer.classList.toggle('hidden', newMode !== '2d');
            covBtn2D.classList.toggle('hidden', newMode !== '2d');
            covBtn3D.classList.toggle('hidden', newMode !== '3d');
            formula1D.classList.toggle('hidden', newMode !== '1d');
            formula2D.classList.toggle('hidden', newMode !== '2d');
            formula3D.classList.toggle('hidden', newMode !== '3d');
            formulaContainer.classList.add('hidden');
            svgOverlay.classList.add('hidden');
            
            if (covarianceMatrixObject) {
                guidesGroup.remove(covarianceMatrixObject);
                covarianceMatrixObject = null;
            }
            popupCov2D.classList.add('hidden');
            popupCov3D.classList.add('hidden');

            setupSceneForMode(newMode);

            if (newMode === '1d') update1DDistribution();
            else if (newMode === '2d') update2DDistribution();
            else if (newMode === '3d') {
                validate3DCorrelation();
                update3DDistribution();
            }
        }
        
        function setupSceneForMode(mode) {
            clearGuides();
            const gridColor = 0x444444;
            const halfSize = PLANE_SIZE / 2;
             const createAxisLabel = (text, position) => {
                const textDiv = document.createElement('div');
                textDiv.className = 'label text-lg italic';
                textDiv.textContent = text;
                const label = new CSS2DObject(textDiv);
                label.position.copy(position);
                guidesGroup.add(label);
            };

            if (mode === '1d') {
                camera.position.set(0, 5, 25);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                const lineMaterial = new THREE.LineBasicMaterial({ color: gridColor });
                const points = [new THREE.Vector3(-halfSize, 0, 0), new THREE.Vector3(halfSize, 0, 0)];
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                guidesGroup.add(new THREE.Line(lineGeometry, lineMaterial));
                for (let i = -halfSize; i <= halfSize; i += 5) {
                    const numDiv = document.createElement('div');
                    numDiv.className = 'label';
                    numDiv.textContent = i;
                    const numLabel = new CSS2DObject(numDiv);
                    numLabel.position.set(i, -0.5, 0);
                    guidesGroup.add(numLabel);
                }
                createAxisLabel('x', new THREE.Vector3(halfSize + 1.5, 0, 0));
                createAxisLabel('-x', new THREE.Vector3(-halfSize - 1.5, 0, 0));
            } else if (mode === '2d') {
                camera.position.set(0, PLANE_SIZE * 0.6, PLANE_SIZE * 0.75);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                guidesGroup.add(new THREE.GridHelper(PLANE_SIZE, PLANE_SIZE, gridColor, gridColor));
                 createAxisLabel('x', new THREE.Vector3(halfSize + 1.5, 0, 0));
                createAxisLabel('z', new THREE.Vector3(0, 0, halfSize + 1.5));
            } else if (mode === '3d') {
                camera.position.set(halfSize * 1.4, halfSize * 0.6, halfSize * 1.4);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                const gridXZ = new THREE.GridHelper(PLANE_SIZE, PLANE_SIZE, gridColor, gridColor);
                gridXZ.position.y = -halfSize;
                guidesGroup.add(gridXZ);
                const gridXY = new THREE.GridHelper(PLANE_SIZE, PLANE_SIZE, gridColor, gridColor);
                gridXY.rotation.x = Math.PI / 2;
                gridXY.position.z = -halfSize;
                guidesGroup.add(gridXY);
                const gridYZ = new THREE.GridHelper(PLANE_SIZE, PLANE_SIZE, gridColor, gridColor);
                gridYZ.rotation.z = Math.PI / 2;
                gridYZ.position.x = -halfSize;
                guidesGroup.add(gridYZ);
            }
        }
        
        function clearVisualization() {
            const clearGroup = (group) => {
                while(group.children.length > 0){ 
                    const child = group.children[0];
                    group.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                }
            };
            clearGroup(visualizationGroup);
            clearGroup(pdfGroup);
            visualizationGroup.add(pdfGroup);
            surfaceMaterialToAnimate = null;
        }

        function clearGuides() {
             while(guidesGroup.children.length > 0){ 
                const child = guidesGroup.children[0];
                guidesGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                if (child.element && child.element.parentNode) child.element.parentNode.removeChild(child.element);
            }
        }

        function update1DSliderText() {
            meanValue.textContent = parseFloat(meanSlider.value).toFixed(2);
            stdDevValue.textContent = parseFloat(stdDevSlider.value).toFixed(2);
        }

        function update1DDistribution() {
            clearVisualization();
            update1DSliderText();
            const mean = parseFloat(meanSlider.value);
            const stdDev = parseFloat(stdDevSlider.value);
            peakPosition.set(mean, maxHistHeight, 0);
            const data = generate1DData(NUM_POINTS, mean, stdDev);
            const hist = createHistogramData(data);
            if (Math.max(...hist.bins) > 0) {
                visualizationGroup.add(createHistogramMesh(hist, maxHistHeight, 'x-1d', 0xef4444));
                pdfGroup.add(create1DPdfCurve(mean, stdDev, maxHistHeight));
            }
        }

        function create1DPdfCurve(mean, stdDev, maxHeight) {
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const points = [];
            const segments = 200;
            const range = PLANE_SIZE / 2;
            const minX = -range;
            const maxX = range;
            const pdf = (x, mu, sigma) => (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2));
            const maxPdfVal = pdf(mean, mean, stdDev);
            if (maxPdfVal <= 0 || !isFinite(maxPdfVal)) return new THREE.Group();
            for (let i = 0; i <= segments; i++) {
                const x = minX + (i / segments) * (maxX - minX);
                const y = (pdf(x, mean, stdDev) / maxPdfVal) * maxHeight;
                points.push(new THREE.Vector3(x, y, 0));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            return new THREE.Line(geometry, material);
        }

        function generate1DData(num, mean, stdDev) {
            return Array.from({length: num}, () => mean + stdDev * randomNormal());
        }

        function update2DSliderText() {
            const stdX = parseFloat(stdDevXSlider2D.value);
            const stdZ = parseFloat(stdDevZSlider2D.value);
            const rho = parseFloat(correlationSlider2D.value);
            stdDevXValue2D.textContent = stdX.toFixed(2);
            stdDevZValue2D.textContent = stdZ.toFixed(2);
            correlationValue2D.textContent = rho.toFixed(2);
            const cov = rho * stdX * stdZ;
            covarianceOutput2D.textContent = `Cov(X,Z) = ${cov.toFixed(2)}`;
            document.getElementById('cov-2d-00').textContent = (stdX**2).toFixed(2);
            document.getElementById('cov-2d-01').textContent = cov.toFixed(2);
            document.getElementById('cov-2d-10').textContent = cov.toFixed(2);
            document.getElementById('cov-2d-11').textContent = (stdZ**2).toFixed(2);
        }
        
        function update2DDistribution() {
            clearVisualization();
            update2DSliderText();
            peakPosition.set(0, maxHistHeight, 0);
            const stdX = parseFloat(stdDevXSlider2D.value);
            const stdZ = parseFloat(stdDevZSlider2D.value);
            const rho = parseFloat(correlationSlider2D.value);
            const data = generateBivariateData(NUM_POINTS, stdX, stdZ, rho);
            const positions = new Float32Array(data.length * 3);
            data.forEach((p, i) => {
                positions[i * 3] = p.x;
                positions[i * 3 + 1] = 0.01;
                positions[i * 3 + 2] = p.z;
            });
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            visualizationGroup.add(new THREE.Points(geom, new THREE.PointsMaterial({ color: 0xcccccc, size: 0.08 })));
            
            const { line } = createContourEllipse(stdX, stdZ, rho);
            pdfGroup.add(line);
            pdfGroup.add(create2DPdfSurface(stdX, stdZ, rho, maxHistHeight));

            const xHist = createHistogramData(data.map(p => p.x));
            const zHist = createHistogramData(data.map(p => p.z));
            const halfSize = PLANE_SIZE / 2;
            if(Math.max(...xHist.bins)>0) {
                visualizationGroup.add(createHistogramMesh(xHist, maxHistHeight, 'x-2d', 0xef4444));
                const xCurve = create1DPdfCurve(0, stdX, maxHistHeight);
                xCurve.position.z = -halfSize - 0.01;
                visualizationGroup.add(xCurve);
            }
            if(Math.max(...zHist.bins)>0) {
                visualizationGroup.add(createHistogramMesh(zHist, maxHistHeight, 'z-2d', 0x3b82f6));
                const zCurve = create1DPdfCurve(0, stdZ, maxHistHeight);
                zCurve.rotation.y = Math.PI / 2;
                zCurve.position.x = -halfSize - 0.01;
                visualizationGroup.add(zCurve);
            }
        }

        function create2DPdfSurface(stdX, stdZ, rho, maxHeight) {
            // const geometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, 50, 50);
            const geometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, 150, 150);
            geometry.rotateX(-Math.PI / 2);
            const pdf = (x, z, sx, sz, r) => {
                if (Math.abs(r) >= 1) return 0;
                const rho2 = r * r;
                const norm = 1 / (2 * Math.PI * sx * sz * Math.sqrt(1 - rho2));
                const exponent = -1 / (2 * (1 - rho2)) * ( (x*x)/(sx*sx) + (z*z)/(sz*sz) - (2*r*x*z)/(sx*sz) );
                return norm * Math.exp(exponent);
            };
            const maxPdfVal = pdf(0, 0, stdX, stdZ, rho);
            if (maxPdfVal <= 0 || !isFinite(maxPdfVal)) return new THREE.Group();
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                positions.setY(i, (pdf(positions.getX(i), positions.getZ(i), stdX, stdZ, rho) / maxPdfVal) * maxHeight);
            }
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
            

            const shader_colour = 0x8f00ff;
            //const shader_colour = 0x34d399;
            const material = new THREE.MeshLambertMaterial({ color: shader_colour, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            
            material.onBeforeCompile = (shader) => {
                shader.uniforms.u_revealX = { value: -PLANE_SIZE / 2 };
                shader.uniforms.u_revealZ = { value: -PLANE_SIZE / 2 };
                shader.vertexShader = 'varying vec2 v_WorldPosXZ;\n' + shader.vertexShader;
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    '#include <begin_vertex>\nv_WorldPosXZ = position.xz;'
                );
                shader.fragmentShader = 'uniform float u_revealX;\nuniform float u_revealZ;\nvarying vec2 v_WorldPosXZ;\n' + shader.fragmentShader;
                shader.fragmentShader = shader.fragmentShader.replace(
                    'void main() {',
                    `void main() {
                        if (v_WorldPosXZ.x > u_revealX || v_WorldPosXZ.y > u_revealZ) {
                            discard;
                        }
                    `
                );
                surfaceMaterialToAnimate = shader;
            };

            const surfaceMesh = new THREE.Mesh(geometry, material);

            const wireframe_colour = 0x34d399;
            // purple
            // const wireframe_colour = 0x8f00ff;
            // white
            // const wireframe_colour = 0xffffff;

            const wireframe = new THREE.LineSegments(new THREE.WireframeGeometry(geometry), new THREE.LineBasicMaterial({ color: wireframe_colour, transparent: true, opacity: 0.2 }));
            const group = new THREE.Group();
            group.add(surfaceMesh, wireframe);
            
            animationStartTime = clock.getElapsedTime();
            return group;
        }

        function generateBivariateData(num, stdX, stdZ, rho) {
            return Array.from({length: num}, () => {
                const z1 = randomNormal(), z2 = randomNormal();
                return { x: stdX * z1, z: stdZ * (z1 * rho + z2 * Math.sqrt(1 - rho*rho)) };
            });
        }
        
        function createContourEllipse(stdX, stdZ, rho) {
            const s = 3; 
            const term1 = stdX**2 + stdZ**2;
            const term2 = Math.sqrt((stdX**2 - stdZ**2)**2 + 4 * rho**2 * stdX**2 * stdZ**2);
            const a = Math.sqrt(0.5 * (term1 + term2)) * s;
            const b = Math.sqrt(0.5 * (term1 - term2)) * s;
            const theta = 0.5 * Math.atan2(2 * rho * stdX * stdZ, stdX**2 - stdZ**2);
            const curve = new THREE.EllipseCurve(0, 0, a, b, 0, 2 * Math.PI, false, theta);
            const points = curve.getPoints(100).map(p => new THREE.Vector3(p.x, 0.01, p.y));
            return { line: new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: 0x34d399, linewidth: 2 })), maxRadius: Math.max(a, b) };
        }

        function update3DSliderText() {
            const sx = parseFloat(stdDevXSlider3D.value), sy = parseFloat(stdDevYSlider3D.value), sz = parseFloat(stdDevZSlider3D.value);
            const rxy = parseFloat(rhoXYSlider.value), rxz = parseFloat(rhoXZSlider.value), ryz = parseFloat(rhoYZSlider.value);
            stdDevXValue3D.textContent = sx.toFixed(2);
            stdDevYValue3D.textContent = sy.toFixed(2);
            stdDevZValue3D.textContent = sz.toFixed(2);
            rhoXYValue.textContent = rxy.toFixed(2);
            rhoXZValue.textContent = rxz.toFixed(2);
            rhoYZValue.textContent = ryz.toFixed(2);
            const covXY = rxy * sx * sy;
            const covXZ = rxz * sx * sz;
            const covYZ = ryz * sy * sz;
            document.getElementById('cov-3d-00').textContent = (sx**2).toFixed(2);
            document.getElementById('cov-3d-11').textContent = (sy**2).toFixed(2);
            document.getElementById('cov-3d-22').textContent = (sz**2).toFixed(2);
            document.getElementById('cov-3d-01').textContent = covXY.toFixed(2);
            document.getElementById('cov-3d-10').textContent = covXY.toFixed(2);
            document.getElementById('cov-3d-02').textContent = covXZ.toFixed(2);
            document.getElementById('cov-3d-20').textContent = covXZ.toFixed(2);
            document.getElementById('cov-3d-12').textContent = covYZ.toFixed(2);
            document.getElementById('cov-3d-21').textContent = covYZ.toFixed(2);
        }

        function validate3DCorrelation() {
            const rxy = parseFloat(rhoXYSlider.value), rxz = parseFloat(rhoXZSlider.value), ryz = parseFloat(rhoYZSlider.value);
            const det = 1 - rxy**2 - rxz**2 - ryz**2 + 2 * rxy * rxz * ryz;
            const isValid = det >= 0;
            document.getElementById('error-message-3d').classList.toggle('hidden', isValid);
            generateButton3D.disabled = !isValid;
            generateButton3D.classList.toggle('bg-gray-500', !isValid);
            generateButton3D.classList.toggle('hover:bg-gray-500', !isValid);
            generateButton3D.classList.toggle('cursor-not-allowed', !isValid);
            generateButton3D.classList.toggle('bg-blue-600', isValid);
            generateButton3D.classList.toggle('hover:bg-blue-700', isValid);
            return isValid;
        }

        function update3DDistribution() {
            update3DSliderText();
            if (!validate3DCorrelation()) {
                clearVisualization();
                return;
            }
            clearVisualization();
            peakPosition.set(0, 0, 0);
            const sx = parseFloat(stdDevXSlider3D.value), sy = parseFloat(stdDevYSlider3D.value), sz = parseFloat(stdDevZSlider3D.value);
            const rxy = parseFloat(rhoXYSlider.value), rxz = parseFloat(rhoXZSlider.value), ryz = parseFloat(rhoYZSlider.value);
            const data = generateTrivariateData(NUM_POINTS, sx, sy, sz, rxy, rxz, ryz);
            const positions = new Float32Array(data.length * 3);
            data.forEach((p, i) => {
                positions[i * 3] = p.x;
                positions[i * 3 + 1] = p.y;
                positions[i * 3 + 2] = p.z;
            });
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const points = new THREE.Points(geom, new THREE.PointsMaterial({ 
                color: 0xffffff,
                size: 0.08,
                transparent: true,
                opacity: 0.8,
                depthWrite: false
             }));
            visualizationGroup.add(points);
            pdfGroup.add(create3DPdfEllipsoid(sx, sy, sz, rxy, rxz, ryz));
        }
        
        function create3DPdfEllipsoid(sx, sy, sz, rxy, rxz, ryz) {
            const group = new THREE.Group();
            const L = [
                [sx, 0, 0],
                [sy * rxy, sy * Math.sqrt(1 - rxy**2), 0],
                [sz * rxz, sz * (ryz - rxy * rxz) / Math.sqrt(1 - rxy**2),
                sz * Math.sqrt(1 - rxz**2 - ((ryz - rxy * rxz)**2) / (1 - rxy**2))]
            ];
            if (isNaN(L[1][1]) || isNaN(L[2][1]) || isNaN(L[2][2])) return group;
            const c = Math.sqrt(11.345);
            const geometry = new THREE.SphereGeometry(c, 32, 32);
            
            const transformMatrix = new THREE.Matrix4().set(
                L[0][0], L[1][0], L[2][0], 0,
                L[0][1], L[1][1], L[2][1], 0,
                L[0][2], L[1][2], L[2][2], 0,
                0,       0,       0,       1
            );

            const material = new THREE.MeshLambertMaterial({
                color: 0x34d399,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const ellipsoid = new THREE.Mesh(geometry, material);
            ellipsoid.applyMatrix4(transformMatrix);

            const wireframe = new THREE.LineSegments(
                new THREE.WireframeGeometry(geometry.clone()), 
                new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
            );
            wireframe.applyMatrix4(transformMatrix);
            
            group.add(ellipsoid, wireframe);
            return group;
        }

        function generateTrivariateData(num, sx, sy, sz, rxy, rxz, ryz) {
            const L = [
                [sx, 0, 0],
                [sy * rxy, sy * Math.sqrt(1 - rxy**2), 0],
                [sz * rxz, sz * (ryz - rxy * rxz) / Math.sqrt(1 - rxy**2), sz * Math.sqrt(1 - rxz**2 - ((ryz - rxy * rxz)**2) / (1 - rxy**2))]
            ];
            if (isNaN(L[1][1]) || isNaN(L[2][1]) || isNaN(L[2][2])) return [];
            
            return Array.from({length: num}, () => {
                const z1 = randomNormal(), z2 = randomNormal(), z3 = randomNormal();
                return {
                    x: L[0][0] * z1 + L[1][0] * z2 + L[2][0] * z3,
                    y: L[0][1] * z1 + L[1][1] * z2 + L[2][1] * z3,
                    z: L[0][2] * z1 + L[1][2] * z2 + L[2][2] * z3
                };
            });
        }

        function onCanvasClick(event) {
            const mouse = new THREE.Vector2((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pdfGroup.children, true);
            if (intersects.length > 0) {
                formulaContainer.classList.remove('hidden');
                svgOverlay.classList.remove('hidden');
                updateFormulaPosition();
            } else {
                formulaContainer.classList.add('hidden');
                svgOverlay.classList.add('hidden');
            }
        }

        function updateFormulaPosition() {
            if (formulaContainer.classList.contains('hidden')) return;
            const screenPosition = peakPosition.clone().project(camera);
            const peakX = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const peakY = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
            formulaContainer.style.left = `${peakX}px`;
            formulaContainer.style.top = `${peakY - 30}px`;
            const panelRect = formulaContainer.getBoundingClientRect();
            connectorLine.setAttribute('x1', peakX);
            connectorLine.setAttribute('y1', peakY);
            connectorLine.setAttribute('x2', panelRect.left + panelRect.width / 2);
            connectorLine.setAttribute('y2', panelRect.bottom);
        }

        function randomNormal() {
            let u=0, v=0;
            while(u===0) u=Math.random(); while(v===0) v=Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function createHistogramMesh(hist, maxHistHeight, axis, color) {
            const histGroup = new THREE.Group();
            const barWidth = hist.range / HISTOGRAM_BINS;
            const maxCount = Math.max(...hist.bins);
            const halfSize = PLANE_SIZE/2;

            hist.bins.forEach((count, i) => {
                if (count > 0) {
                    const height = (count / maxCount) * maxHistHeight;
                    const barGeom = new THREE.BoxGeometry(barWidth * 0.9, height, 0.2);
                    const bar = new THREE.Mesh(barGeom, new THREE.MeshLambertMaterial({color}));
                    const xPos = hist.min + (i + 0.5) * barWidth;
                    if(axis === 'x-1d') bar.position.set(xPos, height/2, 0);
                    else if (axis === 'x-2d') bar.position.set(xPos, height/2, -halfSize);
                    else if (axis === 'z-2d') {
                        bar.rotation.y = Math.PI / 2;
                        bar.position.set(-halfSize, height/2, xPos);
                    }
                    histGroup.add(bar);
                }
            });
            return histGroup;
        }

        function createHistogramData(data) {
            if(data.length === 0) return {bins: [], min:0, range:0};
            let minVal = Math.min(...data), maxVal = Math.max(...data);
            const range = maxVal - minVal || 1;
            const binWidth = range / HISTOGRAM_BINS;
            const bins = new Array(HISTOGRAM_BINS).fill(0);
            data.forEach(val => {
                let binIndex = Math.floor((val - minVal) / binWidth);
                if (binIndex === HISTOGRAM_BINS) binIndex--;
                if (binIndex >= 0 && binIndex < HISTOGRAM_BINS) bins[binIndex]++;
            });
            return { bins, min: minVal, range };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);

            if (covarianceMatrixObject) {
                guidesGroup.remove(covarianceMatrixObject);
                covarianceMatrixObject = null;
            }
            popupCov2D.classList.add('hidden');
            popupCov3D.classList.add('hidden');
        }

        function startConvolveAnimation() {
            if (revealPhase !== 'none') return;
            
            revealPhase = 'sweeping';
            convolveStartTime = clock.getElapsedTime();



            visualizationGroup.visible = false;


            const stdX = parseFloat(stdDevXSlider2D.value);
            const stdZ = parseFloat(stdDevZSlider2D.value);
            const rho = parseFloat(correlationSlider2D.value);

            sweepGroupX = new THREE.Group();
            sweepGroupX.add(create1DPdfCurve(0, stdX, maxHistHeight));
            sweepGroupX.position.z = -PLANE_SIZE/2;
            scene.add(sweepGroupX);
            
            sweepGroupZ = new THREE.Group();
            sweepGroupZ.add(create1DPdfCurve(0, stdZ, maxHistHeight));
            sweepGroupZ.rotation.y = -Math.PI / 2;
            sweepGroupZ.position.x = -PLANE_SIZE/2;
            scene.add(sweepGroupZ);
            
            convolveSurface = create2DPdfSurface(stdX, stdZ, rho, maxHistHeight);
            convolveSurface.visible = true;
            scene.add(convolveSurface);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            //scene.remove(convolveSurface);
            const elapsedTime = clock.getElapsedTime();
            
            if (revealPhase === 'sweeping') {

                // Hide the PDF (ellipse) during sweep
                
                // Make visualization group visible, but hide its points initially
                visualizationGroup.visible = true;


                pointsToReveal = visualizationGroup.children.find(c => c.type === 'Points');
                if (pointsToReveal) pointsToReveal.visible = false;
                
                // Animate the sweep
                const animElapsed = elapsedTime - convolveStartTime;
                const progress = Math.min(animElapsed / 4.0, 1.0); // 4 second sweep
                const halfSize = PLANE_SIZE / 2;
                const currentPos = -halfSize + progress * PLANE_SIZE;

                // Move sweep groups
                if (sweepGroupX) sweepGroupX.position.z = currentPos;
                if (sweepGroupZ) sweepGroupZ.position.x = currentPos;

                // Update shader reveal uniforms
                if (surfaceMaterialToAnimate) {
                    surfaceMaterialToAnimate.uniforms.u_revealX.value = currentPos;
                    surfaceMaterialToAnimate.uniforms.u_revealZ.value = currentPos;
                }

                // Sweep finished
                if (progress >= 1.0) {
                    scene.remove(sweepGroupX);
                    scene.remove(sweepGroupZ);
                    scene.remove(convolveSurface);

                    surfaceMaterialToAnimate.visible = false;

                    // Cleanup sweep groups
                    while (sweepGroupX.children.length > 0) sweepGroupX.remove(sweepGroupX.children[0]);
                    while (sweepGroupZ.children.length > 0) sweepGroupZ.remove(sweepGroupZ.children[0]);
                    if (convolveSurface) {
                        convolveSurface.children.forEach(c => {
                            if (c.geometry) c.geometry.dispose();
                            if (c.material) c.material.dispose();
                        });
                    }

                    // Prepare points reveal
                    revealPhase = 'points';
                    revealStartTime = clock.getElapsedTime();
                    if (pointsToReveal) {
                        pointsToReveal.visible = true;
                        pointsToReveal.geometry.setDrawRange(0, 0);
                    }
                }

            } else if (revealPhase === 'points') {

                const animElapsed = elapsedTime - revealStartTime;
                const progress = Math.min(animElapsed / 2.0, 1.0); // 2 second point reveal

                if (pointsToReveal) {
                    pointsToReveal.visible = true;
                    const count = Math.floor(progress * NUM_POINTS);
                    pointsToReveal.geometry.setDrawRange(0, count);
                }

                // After points fully revealed
                if (progress >= 1.0) {
                    revealPhase = 'none'; // stop animation
                    pdfGroup.visible = true; // show ellipse instantly
                    
                }
            }

            // Always update formula position and render
            updateFormulaPosition();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }



        init();
    </script>
</body>
</html>

