---
date: 2025-08-27
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Interactive Complex Plane</title>
    <style>
        body {
            margin: 0;
            background-color: #000000;
            color: #e5e7eb;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #title-container {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }
        #title-container h1 {
            margin: 0;
            font-size: 1.75rem;
            font-weight: 600;
        }
        #title-container p {
            margin: 0.25rem;
            color: #9ca3af;
        }
        #controls-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(17, 24, 39, 0.8);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid #374151;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            z-index: 101;
            width: 90%;
            max-width: 800px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .control-group label {
            font-weight: 600;
            white-space: nowrap;
            color: #9ca3af;
        }
        .control-group input[type="range"] {
            width: 120px;
            cursor: pointer;
        }
        .control-group .value-display {
            font-weight: bold;
            min-width: 70px;
            text-align: center;
            background-color: #111827;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            color: #e5e7eb;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div id="title-container">
        <h1>Interactive Complex Plane</h1>
        <p>A 3D visualization of waves in the complex domain.</p>
    </div>

    <div id="controls-container">
        <div class="control-group">
            <label for="angle-slider">Angle (θ):</label>
            <input type="range" id="angle-slider" min="0" max="360" value="45" step="1">
            <span id="angle-value" class="value-display">45°</span>
        </div>
        <div class="control-group">
            <label for="frequency-slider">Frequency:</label>
            <!-- UPDATED: The slider is now a simple 0-100 range for the log calculation -->
            <input type="range" id="frequency-slider" min="0" max="100" value="0" step="1">
            <span id="frequency-value" class="value-display">1.0x</span>
        </div>
        <div class="control-group">
            <label for="amplitude-slider">Amplitude:</label>
            <input type="range" id="amplitude-slider" min="0.1" max="2.5" value="1" step="0.1">
            <span id="amplitude-value" class="value-display">1.0</span>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // === Scene Setup ===
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(4, 4, 7);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        // === Lighting ===
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        // === Static Objects ===
        const axisLength = 2.5;
        const axisMaterialX = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const axisMaterialY = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        const pointsX = [new THREE.Vector3(-axisLength, 0, 0), new THREE.Vector3(axisLength, 0, 0)];
        const pointsY = [new THREE.Vector3(0, -axisLength, 0), new THREE.Vector3(0, axisLength, 0)];
        const geometryX = new THREE.BufferGeometry().setFromPoints(pointsX);
        const geometryY = new THREE.BufferGeometry().setFromPoints(pointsY);
        const xAxis = new THREE.Line(geometryX, axisMaterialX);
        const yAxis = new THREE.Line(geometryY, axisMaterialY);
        scene.add(xAxis, yAxis);

        const ringGeometry = new THREE.RingGeometry(1.49, 1.51, 128);
        const ringMaterial = new THREE.MeshBasicMaterial({ color: 0x3b82f6, side: THREE.DoubleSide });
        const unitCircle = new THREE.Mesh(ringGeometry, ringMaterial);
        scene.add(unitCircle);

        // === Dynamic Objects ===
        const vectorGroup = new THREE.Group();
        scene.add(vectorGroup);
        const arrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 1.5, 0xf59e0b, 0.2, 0.1);
        vectorGroup.add(arrow);
        const pointGeometry = new THREE.SphereGeometry(0.05, 16, 16);
        const pointMaterial = new THREE.MeshStandardMaterial({ color: 0xf59e0b, emissive: 0xf59e0b, emissiveIntensity: 2 });
        const vectorPoint = new THREE.Mesh(pointGeometry, pointMaterial);
        vectorPoint.position.x = 1.5;
        vectorGroup.add(vectorPoint);
        const sinMarker = new THREE.Mesh(pointGeometry, new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x3b82f6, emissiveIntensity: 2 }));
        const cosMarker = new THREE.Mesh(pointGeometry, new THREE.MeshStandardMaterial({ color: 0xef4444, emissive: 0xef4444, emissiveIntensity: 2 }));
        const resultMarker = new THREE.Mesh(pointGeometry, new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive: 0x22c55e, emissiveIntensity: 2 }));
        scene.add(sinMarker, cosMarker, resultMarker);

        // === UI Elements ===
        const angleSlider = document.getElementById('angle-slider');
        const angleValueSpan = document.getElementById('angle-value');
        const frequencySlider = document.getElementById('frequency-slider');
        const frequencyValueSpan = document.getElementById('frequency-value');
        const amplitudeSlider = document.getElementById('amplitude-slider');
        const amplitudeValueSpan = document.getElementById('amplitude-value');
        
        let sinWave, cosWave, resultWave;

        // === Functions ===

        const MIN_FREQ = 1;
        const MAX_FREQ = 10000;
        
        function getLogFrequency() {
            const sliderValue = parseFloat(frequencySlider.value);
            const maxSliderValue = parseFloat(frequencySlider.max);
            return MIN_FREQ * Math.pow(MAX_FREQ / MIN_FREQ, sliderValue / maxSliderValue);
        }

        function createAxisLabel(text, position, size = 30) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${size}px Inter, sans-serif`;
            const textMetrics = context.measureText(text);
            canvas.width = textMetrics.width;
            canvas.height = size * 1.5;
            context.font = `Bold ${size}px Inter, sans-serif`;
            context.fillStyle = '#e5e7eb';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width / 100, canvas.height / 100, 1.0);
            sprite.position.copy(position);
            return sprite;
        }

        const xLabel = createAxisLabel('x', new THREE.Vector3(axisLength + 0.3, 0, 0), 30);
        scene.add(xLabel);
        const iLabel = createAxisLabel('i', new THREE.Vector3(0, axisLength + 0.3, 0), 30);
        scene.add(iLabel);

        function regenerateWaves() {
            const frequency = getLogFrequency();
            const amplitude = parseFloat(amplitudeSlider.value);
            
            [sinWave, cosWave, resultWave].forEach(wave => {
                if (wave) { scene.remove(wave); wave.geometry.dispose(); wave.material.dispose(); }
            });

            const baseSegments = 128;
            // FIX: Cap the number of segments to prevent WebGL context loss at extreme frequencies.
            let tubeSegments = Math.max(baseSegments, Math.floor(baseSegments * (frequency / 10)));
            tubeSegments = Math.min(tubeSegments, 4096); // Set a hard cap to prevent crashing.

            const createWave = (func, color, zPos) => {
                const curve = new THREE.Curve();
                curve.getPoint = (t) => {
                    const x = t * 10 - 5;
                    const angle = (t * Math.PI * 2) * frequency;
                    const y = func(angle) * amplitude;
                    return new THREE.Vector3(x, y, zPos);
                };
                const tubeGeometry = new THREE.TubeGeometry(curve, tubeSegments, 0.03, 8, false);
                const tubeMaterial = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
                return new THREE.Mesh(tubeGeometry, tubeMaterial);
            };

            const waveZ = 4;
            sinWave = createWave(Math.sin, 0x3b82f6, -waveZ);
            cosWave = createWave(Math.cos, 0xef4444, -waveZ);
            resultWave = createWave((angle) => Math.sin(angle) + Math.cos(angle), 0x22c55e, waveZ);
            scene.add(sinWave, cosWave, resultWave);
            
            frequencyValueSpan.textContent = `${frequency.toFixed(1)}x`;
            amplitudeValueSpan.textContent = amplitude.toFixed(1);
            updateVisualization();
        }

        function updateVisualization() {
            const angleDegrees = parseInt(angleSlider.value);
            const frequency = getLogFrequency();
            const amplitude = parseFloat(amplitudeSlider.value);
            const angleRadians = angleDegrees * (Math.PI / 180);
            
            vectorGroup.rotation.z = angleRadians;

            const waveX = (angleRadians / (Math.PI * 2)) * 10 - 5;
            const freqAngle = angleRadians * frequency;
            const waveZ = 4;

            sinMarker.position.set(waveX, Math.sin(freqAngle) * amplitude, -waveZ);
            cosMarker.position.set(waveX, Math.cos(freqAngle) * amplitude, -waveZ);
            resultMarker.position.set(waveX, (Math.sin(freqAngle) + Math.cos(freqAngle)) * amplitude, waveZ);

            angleValueSpan.textContent = `${angleDegrees}°`;
            frequencyValueSpan.textContent = `${frequency.toFixed(1)}x`;
        }

        // === Event Listeners ===
        angleSlider.addEventListener('input', updateVisualization);
        frequencySlider.addEventListener('input', regenerateWaves);
        amplitudeSlider.addEventListener('input', regenerateWaves);

        // === Animation Loop ===
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // === Initial State & Resize Handler ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        regenerateWaves();
        animate();
    </script>
</body>
</html>
