---
layout: page
title: 3D Quaternion Visualizer
date: 2025-08-31 04:24:00 +0200
description: An interactive web application to visualize 3D quaternion rotations in real-time. Adjust the imaginary components to see how they affect the rotation of a wireframe sphere in a 3D space with a grid and labeled axes.
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Quaternion Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            margin: 0;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #canvas-container {
            flex-grow: 1;
            width: 100%;
            position: relative;
        }

        .slider-group {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: nowrap;
        }

        .slider-label {
            width: 1rem;
            margin-right: 1.5rem;
            font-weight: bold;
            font-size: 1.25rem;
            line-height: 1.75rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 12px;
            background: #4a5568;
            border-radius: 6px;
            outline: none;
            transition: opacity .2s;
            flex-grow: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #4299e1;
            border: 2px solid #a0aec0;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #4299e1;
            border: 2px solid #a0aec0;
            border-radius: 50%;
            cursor: pointer;
        }

        .value-display {
            width: 4rem;
            margin-left: 1rem;
            text-align: center;
            font-size: 1rem;
            line-height: 1.5rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div id="container" class="flex flex-col items-center justify-center h-screen w-screen">

        <h1 class="text-3xl font-bold my-4 md:my-6 text-center">3D Quaternion Visualizer</h1>
        <div id="canvas-container" class="w-full h-full relative"></div>

        <div id="controls" class="w-full max-h-1/2 overflow-y-auto flex flex-col items-center p-6 bg-gray-800 rounded-t-xl shadow-xl">
            <h2 class="text-xl font-semibold mb-4 text-center">Quaternion Controls</h2>
            <!-- Quaternion Display -->
            <div id="quaternion-display" class="bg-gray-900 p-2 rounded-lg text-sm md:text-base mb-6 font-mono text-center">
                <p>Quaternion: <span id="w-val" class="text-cyan-400">0.00</span> + <span id="i-val" class="text-red-400">0.00i</span> + <span id="j-val" class="text-green-400">0.00j</span> + <span id="k-val" class="text-yellow-400">0.00k</span></p>
            </div>

            <div class="flex flex-col gap-4 w-full max-w-sm">
                <!-- i (x) component control -->
                <div class="flex flex-col items-center bg-gray-700 p-4 rounded-lg">
                    <div class="slider-group w-full">
                        <label class="slider-label text-red-400">i</label>
                        <input type="range" id="slider-i" min="-1" max="1" step="0.01" value="0" class="w-full cursor-pointer rounded-full">
                        <span id="value-i" class="value-display text-lg">0.00</span>
                    </div>
                </div>

                <!-- j (y) component control -->
                <div class="flex flex-col items-center bg-gray-700 p-4 rounded-lg">
                    <div class="slider-group w-full">
                        <label class="slider-label text-green-400">j</label>
                        <input type="range" id="slider-j" min="-1" max="1" step="0.01" value="0" class="w-full cursor-pointer rounded-full">
                        <span id="value-j" class="value-display text-lg">0.00</span>
                    </div>
                </div>

                <!-- k (z) component control -->
                <div class="flex flex-col items-center bg-gray-700 p-4 rounded-lg">
                    <div class="slider-group w-full">
                        <label class="slider-label text-yellow-400">k</label>
                        <input type="range" id="slider-k" min="-1" max="1" step="0.01" value="0" class="w-full cursor-pointer rounded-full">
                        <span id="value-k" class="value-display text-lg">0.00</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // --- SCENE SETUP ---
            const scene = new THREE.Scene();
            const canvasContainer = document.getElementById('canvas-container');
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvasContainer.appendChild(renderer.domElement);

            const camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.z = 2.5;

            // --- OBJECTS ---
            const group = new THREE.Group();
            scene.add(group);

            // Sphere color: Teal
            const sphereColor = 0x64CCC5;

            // Semi-transparent sphere
            const sphereGeometry = new THREE.SphereGeometry(0.4, 24, 24); // Reduced density
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: sphereColor, transparent: true, opacity: 0.3, shininess: 100 });
            const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            group.add(sphereMesh);

            // Wireframe sphere
            const wireframeGeometry = new THREE.WireframeGeometry(sphereGeometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({ color: sphereColor, linewidth: 2 });
            const wireframeMesh = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
            group.add(wireframeMesh);

            // Add top/bottom markers for distinct poles as text
            function makeTextSprite(message, color) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const fontSize = 128;
                const font = `bold ${fontSize}px Inter, sans-serif`;
                context.font = font;

                const metrics = context.measureText(message);
                const textWidth = metrics.width;
                const textHeight = fontSize * 1.5;

                canvas.width = textWidth + 10;
                canvas.height = textHeight;
                context.font = font;
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(message, canvas.width / 2, canvas.height / 2);

                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.2 * textWidth / textHeight, 0.2, 1);
                return sprite;
            }

            const northLabel = makeTextSprite('N', '#F56565'); // Red for North
            northLabel.position.set(0, 0.55, 0);
            group.add(northLabel);

            const southLabel = makeTextSprite('S', '#4299e1'); // Blue for South
            southLabel.position.set(0, -0.55, 0);
            group.add(southLabel);

            // Grid plane (shorter again)
            const gridHelper = new THREE.GridHelper(3, 6, 0x5a67d8, 0x4a5568);
            scene.add(gridHelper);

            // --- LIGHTING ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(2, 5, 3);
            scene.add(directionalLight);

            // --- CONTROLS & HELPERS ---
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Axis Helper (shorter again)
            const axesHelper = new THREE.AxesHelper(1.5);
            scene.add(axesHelper);

            // --- AXIS LABELS ---
            const iLabel = makeTextSprite('i', '#F56565'); // red
            iLabel.position.set(0.8, 0, 0);
            scene.add(iLabel);

            const jLabel = makeTextSprite('j', '#48BB78'); // green
            jLabel.position.set(0, 0.8, 0);
            scene.add(jLabel);

            const kLabel = makeTextSprite('k', '#ECC94B'); // yellow
            kLabel.position.set(0, 0, 0.8);
            scene.add(kLabel);

            // --- UI ELEMENTS ---
            const sliderI = document.getElementById('slider-i');
            const sliderJ = document.getElementById('slider-j');
            const sliderK = document.getElementById('slider-k');
            const valueI = document.getElementById('value-i');
            const valueJ = document.getElementById('value-j');
            const valueK = document.getElementById('value-k');
            const wValDisplay = document.getElementById('w-val');
            const iValDisplay = document.getElementById('i-val');
            const jValDisplay = document.getElementById('j-val');
            const kValDisplay = document.getElementById('k-val');

            const q = new THREE.Quaternion();

            // --- UPDATE FUNCTION ---
            function updateQuaternion() {
                try {
                    // Get values from sliders
                    const iVal = parseFloat(sliderI.value);
                    const jVal = parseFloat(sliderJ.value);
                    const kVal = parseFloat(sliderK.value);

                    const iSq = iVal * iVal;
                    const jSq = jVal * jVal;
                    const kSq = kVal * kVal;
                    const sumSq = iSq + jSq + kSq;

                    // Ensure sum of squares is not greater than 1
                    if (sumSq > 1) {
                        const scale = 1 / Math.sqrt(sumSq);
                        q.x = iVal * scale;
                        q.y = jVal * scale;
                        q.z = kVal * scale;
                    } else {
                        q.x = iVal;
                        q.y = jVal;
                        q.z = kVal;
                    }

                    // Calculate the real part (w) to maintain a unit quaternion
                    q.w = Math.sqrt(Math.max(0, 1 - q.x * q.x - q.y * q.y - q.z * q.z));

                    // Apply the quaternion to the group
                    group.quaternion.copy(q);

                    // Update the value displays
                    valueI.textContent = iVal.toFixed(2);
                    valueJ.textContent = jVal.toFixed(2);
                    valueK.textContent = kVal.toFixed(2);

                    // Update the quaternion display
                    wValDisplay.textContent = q.w.toFixed(2);
                    iValDisplay.textContent = `${q.x.toFixed(2)}i`;
                    jValDisplay.textContent = `${q.y.toFixed(2)}j`;
                    kValDisplay.textContent = `${q.z.toFixed(2)}k`;

                } catch (e) {
                    console.error('Error updating quaternion:', e);
                }
            }

            // --- EVENT LISTENERS ---
            sliderI.addEventListener('input', updateQuaternion);
            sliderJ.addEventListener('input', updateQuaternion);
            sliderK.addEventListener('input', updateQuaternion);

            // Initial update
            updateQuaternion();

            // --- RENDER LOOP ---
            function animate() {
                requestAnimationFrame(animate);
                controls.update(); // only required if controls.enableDamping is true
                renderer.render(scene, camera);
            }

            // --- RESPONSIVE RESIZING ---
            window.addEventListener('resize', () => {
                const newWidth = canvasContainer.clientWidth;
                const newHeight = canvasContainer.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            });

            // Start the animation loop
            animate();
        };
    </script>
</body>
</html>

