<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR Joystick Locomotion</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; font-family: sans-serif; background-color: #000; color: #fff; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
        }
        a { color: skyblue }
    </style>
</head>
<body>
    <div id="info">
        WebXR Joystick Locomotion Demo<br />
        <b>Inline View:</b> Click & Drag to Look | <b>VR Mode:</b> Move with Left Joystick, Rotate with Right Joystick
    </div>

    <!-- The 'importmap' allows us to use modules like 'three' without specifying full paths. -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // --- Core Components ---
        let camera, scene, renderer;
        let player; // This will be a Group that holds the camera, representing the user
        let leftController, rightController;

        // --- Movement State ---
        const moveSpeed = 0.05; // How fast the player moves
        const rotateSpeed = 0.03; // How fast the player rotates
        const deadzone = 0.15; // Joystick deadzone to prevent drift

        // --- Inline View (Mouse) State ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };


        init();
        animate();

        function init() {
            // --- Scene Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // --- Camera Setup ---
            // The camera represents the user's head. We'll add it to a 'player' group
            // to handle movement and rotation separately from the head tracking.
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0); // Set camera at an average human height

            // --- Player Setup ---
            // This Group acts as our player capsule. We move and rotate this object.
            // The camera is a child of it, so it comes along for the ride.
            player = new THREE.Group();
            player.position.set(0, 0, 2); // Start position in the world
            player.add(camera);
            scene.add(player);

            // --- World Geometry ---
            // A simple grid floor to give a sense of movement.
            const gridHelper = new THREE.GridHelper(50, 50);
            scene.add(gridHelper);

            // Add some colorful cubes to the scene to make it easier to see rotation and movement.
            const boxGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            for (let i = 0; i < 20; i++) {
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(Math.random(), Math.random(), Math.random())
                });
                const cube = new THREE.Mesh(boxGeometry, material);
                cube.position.set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() * 2) + 0.25,
                    (Math.random() - 0.5) * 20
                );
                cube.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                scene.add(cube);
            }

            // --- Lighting ---
            const ambientLight = new THREE.HemisphereLight(0x606060, 0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // --- Renderer Setup ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // --- WebXR Setup ---
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // --- Controller Setup ---
            leftController = renderer.xr.getController(0);
            rightController = renderer.xr.getController(1);
            player.add(leftController, rightController); // Add controllers to the player group

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize);

            // --- Inline View (Mouse) Listeners ---
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp); // Also stop on mouse leave
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Mouse Control Functions for Inline View ---
        function onMouseDown(e) {
            // Don't do anything if we are in VR
            if (renderer.xr.isPresenting) return;
            isDragging = true;
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        }

        function onMouseMove(e) {
            // Only rotate if dragging and not in VR
            if (!isDragging || renderer.xr.isPresenting) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            // Rotate the entire player group for yaw (left/right)
            player.rotation.y -= deltaX * 0.004;
            
            // Rotate just the camera for pitch (up/down) and clamp it
            camera.rotation.x -= deltaY * 0.004;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        }

        function onMouseUp() {
            isDragging = false;
        }


        function handleControls() {
            if (!renderer.xr.isPresenting) return; // Only handle joystick controls in VR

            // --- Gamepad Access ---
            // WebXR gamepads are accessed via the controller's 'gamepad' property.
            const leftGamepad = leftController.gamepad;
            const rightGamepad = rightController.gamepad;

            // --- Left Joystick (Movement) ---
            if (leftGamepad && leftGamepad.axes.length > 0) {
                const moveX = leftGamepad.axes[2] || 0; // X-axis (left/right)
                const moveZ = leftGamepad.axes[3] || 0; // Y-axis (forward/backward)

                // The direction the camera is facing in the XY plane
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                cameraDirection.y = 0; // We don't want to move up/down
                cameraDirection.normalize();

                // The "strafe" direction is 90 degrees to the camera direction
                const strafeDirection = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), cameraDirection);
                
                // Move forward/backward based on camera direction
                if (Math.abs(moveZ) > deadzone) {
                    player.position.addScaledVector(cameraDirection, -moveZ * moveSpeed);
                }

                // Strafe left/right
                if (Math.abs(moveX) > deadzone) {
                    player.position.addScaledVector(strafeDirection, -moveX * moveSpeed);
                }
            }

            // --- Right Joystick (Rotation) ---
            if (rightGamepad && rightGamepad.axes.length > 0) {
                const rotateX = rightGamepad.axes[2] || 0; // X-axis

                if (Math.abs(rotateX) > deadzone) {
                    // Rotate the entire player group around the Y-axis
                    player.rotation.y -= rotateX * rotateSpeed;
                }
            }
        }


        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            handleControls();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

