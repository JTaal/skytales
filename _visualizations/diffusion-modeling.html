---
date: 2025-08-29
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffusion Model</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Source+Serif+4:opsz,wght@8..60,400;8..60,700&display=swap');
        :root { 
            --header-height: 140px;
            --footer-height: 80px; 
        }
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
        }
        #top-header {
            /* REMOVED: position: absolute. Now part of the flex flow. */
            flex-shrink: 0; /* Ensures header doesn't shrink */
            height: var(--header-height);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
            padding-top: 1rem;
        }
        #top-header h1 {
            font-family: 'Source Serif 4', serif;
            font-weight: 700;
            font-size: 2.5rem;
            line-height: 1.1;
            letter-spacing: -0.02em;
        }
        #top-header p {
             font-size: 1rem;
             color: #94a3b8;
             margin-top: 0.25rem;
        }
        #shape-controls {
            margin-top: 1rem;
            display: flex;
            gap: 0.75rem;
        }
        #main-container {
            display: flex;
            flex: 1; /* Takes up all remaining space */
            overflow: hidden;
            width: 100vw;
            /* REMOVED: padding-top. No longer needed. */
        }
        .viz-container {
            position: relative;
            width: 33.3333%;
            height: 100%;
            border-left: 1px solid #1e293b;
        }
        .viz-container:first-child { border-left: none; }
        .viz-container.fullscreen {
            position: fixed;
            top: 0; left: 0;
            width: 100vw !important;
            height: calc(100vh - var(--footer-height)) !important;
            z-index: 50;
            border-left: none;
        }
        canvas { display: block; }
        .ui-footer {
            position: relative;
            z-index: 60;
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
            text-align: center;
            height: var(--footer-height);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .controls-grid {
            display: flex;
            gap: 2.5rem;
            align-items: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .control-group label {
            font-size: 0.8rem; 
            font-weight: 500; 
            color: #cbd5e1;
            white-space: nowrap;
        }
        .slider {
            -webkit-appearance: none; width: 220px; height: 6px;
            background: #334155; border-radius: 3px; outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; background: #a78bfa;
            cursor: pointer; border-radius: 50%; border: 2px solid #fff;
        }
        .toggle-button, .shape-btn {
            cursor: pointer; padding: 0.35rem 1rem; border-radius: 99px;
            font-size: 0.8rem; background-color: #334155;
            transition: background-color 0.2s; user-select: none;
            color: white; border: none;
        }
        .toggle-button.active, .shape-btn.active { background-color: #a78bfa; }
        .viz-title {
            position: absolute;
            top: 1rem; left: 50%; transform: translateX(-50%);
            z-index: 5; color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem; pointer-events: none;
        }
        .display-value {
            font-family: monospace; font-size: 0.8rem; color: #a78bfa;
            min-width: 50px; text-align: left;
        }
        .fullscreen-btn {
            position: absolute; bottom: 1rem; right: 1rem;
            z-index: 6; cursor: pointer;
            background-color: rgba(30, 41, 59, 0.5);
            padding: 0.5rem; border-radius: 50%;
            transition: background-color 0.2s;
        }
        .fullscreen-btn:hover { background-color: rgba(51, 65, 85, 0.8); }
        #return-btn {
            position: fixed; bottom: calc(var(--footer-height) + 1rem); right: 1rem;
            z-index: 100;
            background-color: #a78bfa; color: white;
            padding: 0.5rem 1rem; border-radius: 99px;
            font-size: 0.8rem; font-weight: 500;
            cursor: pointer;
        }
        .contextual-controls {
            display: none;
        }
        .viz-container.fullscreen .contextual-controls {
            display: flex;
            position: absolute;
            top: 3.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 55;
            gap: 1rem;
            align-items: center;
            background-color: rgba(30, 41, 59, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 99px;
            backdrop-filter: blur(5px);
        }
        .hidden { display: none !important; }

        @media (max-width: 768px) {
            :root {
                --header-height: 120px;
                --footer-height: 70px;
            }
            #top-header h1 { font-size: 1.75rem; }
            #top-header p { font-size: 0.875rem; }
            #main-container {
                flex-direction: column;
            }
            .viz-container {
                width: 100%;
                height: 33.3333%;
                border-left: none;
                border-top: 1px solid #1e293b;
            }
            .viz-container.fullscreen {
                 height: calc(100vh - var(--footer-height)) !important;
            }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="top-header">
        <div>
            <h1>Diffusion Model</h1>
            <p>a universal probability distribution approximator</p>
        </div>
        <div id="shape-controls">
            <button class="shape-btn active" data-shape="sphere">Sphere</button>
            <button class="shape-btn" data-shape="box">Cube</button>
            <button class="shape-btn" data-shape="torus">Torus</button>
        </div>
    </div>

    <main id="main-container">
        <div id="container1" class="viz-container" data-id="1">
            <div class="viz-title">1. Forward Process</div>
            <div class="contextual-controls">
                <div class="control-group">
                    <label for="maxVarianceSlider">Max Variance (Log)</label>
                    <div class="flex items-center gap-2">
                        <input id="maxVarianceSlider" type="range" min="0" max="100" value="50" step="1" class="slider">
                        <span id="maxVarianceDisplay" class="display-value">~158</span>
                    </div>
                </div>
            </div>
            <div class="fullscreen-btn" data-id="1"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-white" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg></div>
        </div>
        <div id="container2" class="viz-container" data-id="2">
            <div class="viz-title">2. Score Field</div>
            <div class="contextual-controls">
                <button id="modeToggle" class="toggle-button active">Slice</button>
                <input id="zSlider" type="range" min="-20" max="20" value="0" step="0.1" class="slider w-[150px]">
            </div>
            <div class="fullscreen-btn" data-id="2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-white" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg></div>
        </div>
        <div id="container3" class="viz-container" data-id="3">
            <div class="viz-title">3. Reverse Process</div>
            <div class="contextual-controls">
                 <div class="control-group">
                    <label for="particleDensitySlider">Particle Density</label>
                    <div class="flex items-center gap-2">
                        <input id="particleDensitySlider" type="range" min="16" max="128" value="48" step="1" class="slider">
                        <span id="particleDensityDisplay" class="display-value">~2.5k</span>
                    </div>
                </div>
            </div>
            <div class="fullscreen-btn" data-id="3"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-white" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg></div>
        </div>
    </main>

    <footer class="ui-footer">
        <div class="controls-grid">
            <div class="control-group">
                <label for="timeStep">$\text{Time Step }(t)$</label>
                <div class="flex items-center gap-2">
                    <input id="timeStep" type="range" min="0" max="1" value="0.75" step="0.001" class="slider">
                    <span id="varianceDisplay" class="display-value">$\sigma^2=0.00$</span>
                </div>
            </div>
        </div>
    </footer>

    <button id="return-btn" class="hidden">Return</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Config & State ---
        let scoreFieldMode = 'slice';
        let zSlicePosition = 0;
        let NUM_WALKERS = 0;
        let MAX_VARIANCE = 25;
        let particleDensity = 48;
        let currentShape = 'sphere';
        const shapeParams = {
            sphere: { radius: 10 },
            box: { size: 15 },
            torus: { radius: 8, tube: 3 }
        };
        const originalSizes = {};
        const MIN_LOG_VARIANCE = 5;
        const MAX_LOG_VARIANCE = 5000;


        // --- Viz Objects ---
        let scene1, camera1, renderer1, controls1, particles1, originalPositions1;
        let scene2, camera2, renderer2, controls2, arrows = [], wireframe2;
        let scene3, camera3, renderer3, controls3, walkers = [], wireframe3;
        
        const container1 = document.getElementById('container1');
        const container2 = document.getElementById('container2');
        const container3 = document.getElementById('container3');

        // --- Shape Switching Logic ---
        function switchShape(newShape) {
            currentShape = newShape;
            
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.shape === newShape);
            });

            createShapeParticles(newShape);
            
            const particleCount = NUM_WALKERS;
            const densityDisplay = document.getElementById('particleDensityDisplay');
            if (particleCount > 1000) {
                densityDisplay.textContent = `~${(particleCount/1000).toFixed(1)}k`;
            } else {
                densityDisplay.textContent = particleCount;
            }

            if(wireframe2) scene2.remove(wireframe2);
            const wireframeGeom2 = createShapeGeometry(newShape);
            const wireframeMat2 = new THREE.MeshBasicMaterial({ color: 0x2dd4bf, wireframe: true, transparent: true, opacity: 0.2 });
            wireframe2 = new THREE.Mesh(wireframeGeom2, wireframeMat2);
            scene2.add(wireframe2);

            if(wireframe3) scene3.remove(wireframe3);
            const wireframeGeom3 = createShapeGeometry(newShape);
            const wireframeMat3 = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.3 });
            wireframe3 = new THREE.Mesh(wireframeGeom3, wireframeMat3);
            scene3.add(wireframe3);

            regenerateScoreFieldArrows();
            updateAllVisuals();
        }

        function createShapeGeometry(shapeName) {
            const p = shapeParams[shapeName];
            const density = Math.floor(particleDensity);
            const boxDensity = Math.floor(density / 4);
            const torusDensity = Math.floor(density * 1.5);

            switch(shapeName) {
                case 'box': return new THREE.BoxGeometry(p.size, p.size, p.size, boxDensity, boxDensity, boxDensity);
                case 'torus': return new THREE.TorusGeometry(p.radius, p.tube, 32, torusDensity);
                case 'sphere':
                default: return new THREE.SphereGeometry(p.radius, density, density);
            }
        }

        // --- Init Functions ---
        function init1() {
            scene1 = new THREE.Scene();
            camera1 = new THREE.PerspectiveCamera(75, container1.clientWidth / container1.clientHeight, 0.1, 1000);
            camera1.position.z = 45;
            renderer1 = new THREE.WebGLRenderer({ antialias: true });
            renderer1.setSize(container1.clientWidth, container1.clientHeight);
            renderer1.setPixelRatio(window.devicePixelRatio);
            container1.appendChild(renderer1.domElement);
            controls1 = new OrbitControls(camera1, renderer1.domElement);
            controls1.enableDamping = true;
        }

        function init2() {
            scene2 = new THREE.Scene();
            camera2 = new THREE.PerspectiveCamera(75, container2.clientWidth / container2.clientHeight, 0.1, 1000);
            camera2.position.set(0, 0, 50);
            renderer2 = new THREE.WebGLRenderer({ antialias: true });
            renderer2.setSize(container2.clientWidth, container2.clientHeight);
            renderer2.setPixelRatio(window.devicePixelRatio);
            container2.appendChild(renderer2.domElement);
            controls2 = new OrbitControls(camera2, renderer2.domElement);
            controls2.enableDamping = true;
        }

        function init3() {
            scene3 = new THREE.Scene();
            camera3 = new THREE.PerspectiveCamera(75, container3.clientWidth / container3.clientHeight, 0.1, 1000);
            camera3.position.set(0, 0, 48);
            renderer3 = new THREE.WebGLRenderer({ antialias: true });
            renderer3.setSize(container3.clientWidth, container3.clientHeight);
            renderer3.setPixelRatio(window.devicePixelRatio);
            container3.appendChild(renderer3.domElement);
            controls3 = new OrbitControls(camera3, renderer3.domElement);
            controls3.enableDamping = true;
        }
        
        function createShapeParticles(shapeName) {
            if (particles1) scene1.remove(particles1);
            
            const geometry = createShapeGeometry(shapeName);
            const material = new THREE.PointsMaterial({ size: 0.15, vertexColors: true });
            originalPositions1 = geometry.attributes.position.clone().array;
            NUM_WALKERS = geometry.attributes.position.count;
            const colors = new Float32Array(originalPositions1.length).fill(1);
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles1 = new THREE.Points(geometry, material);
            scene1.add(particles1);

            walkers.forEach(w => scene3.remove(w));
            walkers = [];
            for (let i = 0; i < NUM_WALKERS; i++) {
                const walkerGeom = new THREE.SphereGeometry(0.15, 8, 8);
                const walkerMat = new THREE.MeshBasicMaterial({ color: 0xc084fc });
                const walker = new THREE.Mesh(walkerGeom, walkerMat);
                walkers.push(walker);
                scene3.add(walker);
            }
        }

        function updateDiffusion(variance) {
            if(!particles1) return;
            const positions = particles1.geometry.attributes.position.array;
            const colors = particles1.geometry.attributes.color.array;
            const cWhite = new THREE.Color(0xffffff), cBlue = new THREE.Color(0x2563eb), cGreen = new THREE.Color(0x16a34a), cRed = new THREE.Color(0xdc2626);

            for (let i = 0; i < positions.length; i += 3) {
                const randomVec = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2).normalize().multiplyScalar(variance * Math.random());
                positions[i] = originalPositions1[i] + randomVec.x;
                positions[i+1] = originalPositions1[i+1] + randomVec.y;
                positions[i+2] = originalPositions1[i+2] + randomVec.z;

                const dist = randomVec.length();
                const color = new THREE.Color();
                if (dist < 1) color.lerpColors(cWhite, cBlue, dist);
                else if (dist < 8) color.lerpColors(cBlue, cGreen, (dist - 1) / 7);
                else color.lerpColors(cGreen, cRed, Math.min((dist - 8) / (MAX_VARIANCE - 8), 1.0));
                
                color.toArray(colors, i);
            }
            particles1.geometry.attributes.position.needsUpdate = true;
            particles1.geometry.attributes.color.needsUpdate = true;
        }
        
        function regenerateScoreFieldArrows() {
            arrows.forEach(arrow => scene2.remove(arrow));
            arrows = [];
            const p = shapeParams[currentShape];
            const effectiveRadius = p.radius || p.size || 10;
            if (scoreFieldMode === 'slice') {
                const gridSize = 20, gridDivs = 15, step = (gridSize*2)/gridDivs;
                for (let x = -gridSize; x <= gridSize; x += step) for (let y = -gridSize; y <= gridSize; y += step) {
                    const pos = new THREE.Vector3(x, y, zSlicePosition);
                    const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), pos, 1, 0x2dd4bf, 1, 0.5);
                    arrows.push(arrow); scene2.add(arrow);
                }
            } else {
                const gridSize = 15, gridDivs = 8, step = (gridSize*2)/gridDivs;
                for (let x = -gridSize; x <= gridSize; x += step) for (let y = -gridSize; y <= gridSize; y += step) for (let z = -gridSize; z <= gridSize; z += step) {
                    const pos = new THREE.Vector3(x, y, z);
                    if (pos.length() < effectiveRadius + 1) continue;
                    const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), pos, 1, 0x2dd4bf, 1, 0.5);
                    arrows.push(arrow); scene2.add(arrow);
                }
            }
            if (typeof updateAllVisuals === 'function') updateAllVisuals();
        }
        
        function getNearestPointOnManifold(point) {
            const p = point.clone();
            const params = shapeParams[currentShape];
            switch(currentShape) {
                case 'box':
                    const s = params.size / 2;
                    return p.clamp(new THREE.Vector3(-s,-s,-s), new THREE.Vector3(s,s,s));
                case 'torus':
                    const R = params.radius;
                    const p_xy = new THREE.Vector3(p.x, p.y, 0);
                    const nearest_on_ring = p_xy.normalize().multiplyScalar(R);
                    const from_ring_to_p = new THREE.Vector3().subVectors(p, nearest_on_ring);
                    const nearest_on_tube = from_ring_to_p.normalize().multiplyScalar(params.tube);
                    return nearest_on_ring.add(nearest_on_tube);
                case 'sphere':
                default:
                    const effectiveRadius = params.radius || params.size || 10;
                    return p.normalize().multiplyScalar(effectiveRadius);
            }
        }
        
        function updateScoreField(variance) {
            arrows.forEach(arrow => {
                const p = arrow.position;
                const nearest = getNearestPointOnManifold(p);
                const dir = new THREE.Vector3().subVectors(nearest, p);
                const len = dir.length() / (1 + variance * 0.4);
                arrow.setDirection(dir.normalize());
                arrow.setLength(Math.max(0.1, len), 0.8, 0.4);
            });
        }

        function resetWalkers() {
            if (!walkers || walkers.length === 0) return;
            const t = parseFloat(document.getElementById('timeStep').value);
            const variance = t * MAX_VARIANCE;
            walkers.forEach(walker => {
                const originalPoint = getNearestPointOnManifold(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(100));
                const noise = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(variance * (0.8 + Math.random() * 0.4));
                walker.position.copy(originalPoint.add(noise));
            });
        }

        function animateGeneration() {
            if (!walkers || walkers.length === 0) return;
            walkers.forEach((walker) => {
                const p = walker.position;
                const nearest = getNearestPointOnManifold(p);
                const dist = p.distanceTo(nearest);

                if (dist < 0.1) return;

                const score = new THREE.Vector3().subVectors(nearest, p);
                const drift = score.clone().multiplyScalar(0.01);
                const noise = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(dist * 0.05);
                
                p.add(drift).add(noise);
            });
        }

        function updateAllVisuals() {
            const t = parseFloat(document.getElementById('timeStep').value);
            const variance = t * MAX_VARIANCE;
            const varianceDisplay = document.getElementById('varianceDisplay');
            varianceDisplay.innerHTML = `$\\sigma^2=${variance.toFixed(2)}$`;
            if(window.MathJax) {
                MathJax.typesetPromise([varianceDisplay]).catch(() => {});
            }
            updateDiffusion(variance);
            updateScoreField(variance);
            resetWalkers();
        }

        // --- Event Listeners ---
        document.getElementById('timeStep').addEventListener('input', updateAllVisuals);
        document.querySelectorAll('.shape-btn').forEach(btn => btn.addEventListener('click', () => switchShape(btn.dataset.shape)));
        
        const modeBtn = document.getElementById('modeToggle'), zSlider = document.getElementById('zSlider');
        modeBtn.addEventListener('click', () => {
            scoreFieldMode = (scoreFieldMode === 'slice') ? 'grid' : 'slice';
            modeBtn.textContent = scoreFieldMode === 'slice' ? 'Slice' : '3D Grid';
            modeBtn.classList.toggle('active', scoreFieldMode === 'slice');
            zSlider.style.display = scoreFieldMode === 'slice' ? 'block' : 'none';
            regenerateScoreFieldArrows();
        });

        zSlider.addEventListener('input', (e) => {
            zSlicePosition = parseFloat(e.target.value);
            regenerateScoreFieldArrows();
        });

        const returnBtn = document.getElementById('return-btn');
        document.querySelectorAll('.fullscreen-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const id = e.currentTarget.dataset.id;
                document.querySelector(`.viz-container[data-id="${id}"]`).classList.add('fullscreen');
                returnBtn.classList.remove('hidden');
                onWindowResize();
            });
        });

        returnBtn.addEventListener('click', () => {
            document.querySelector('.fullscreen')?.classList.remove('fullscreen');
            returnBtn.classList.add('hidden');
            setTimeout(onWindowResize, 50);
        });
        
        function getLogVariance(sliderValue) {
            const maxSliderValue = 100;
            return MIN_LOG_VARIANCE * Math.pow(MAX_LOG_VARIANCE / MIN_LOG_VARIANCE, sliderValue / maxSliderValue);
        }

        const maxVarianceSlider = document.getElementById('maxVarianceSlider');
        maxVarianceSlider.addEventListener('input', (e) => {
            const sliderVal = parseInt(e.target.value);
            MAX_VARIANCE = getLogVariance(sliderVal);
            const displayVal = MAX_VARIANCE > 1000 ? `${(MAX_VARIANCE/1000).toFixed(1)}k` : Math.round(MAX_VARIANCE);
            document.getElementById('maxVarianceDisplay').textContent = displayVal;
            updateAllVisuals();
        });

        const particleDensitySlider = document.getElementById('particleDensitySlider');
        particleDensitySlider.addEventListener('input', (e) => {
            particleDensity = parseInt(e.target.value);
            switchShape(currentShape); 
        });


        function onWindowResize() {
            const allContainers = document.querySelectorAll('.viz-container');
            const renderers = [renderer1, renderer2, renderer3];
            const cameras = [camera1, camera2, camera3];

            allContainers.forEach(c => {
                const id = c.dataset.id;
                let width, height;

                if (c.classList.contains('fullscreen')) {
                    width = window.innerWidth;
                    height = window.innerHeight - document.querySelector('.ui-footer').offsetHeight;
                } else {
                    width = originalSizes[id] ? originalSizes[id].width : c.clientWidth;
                    height = originalSizes[id] ? originalSizes[id].height : c.clientHeight;
                }
                
                const renderer = renderers[id - 1];
                const camera = cameras[id - 1];

                if (renderer && camera && width > 0 && height > 0) {
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            animateGeneration();
            controls1.update(); renderer1.render(scene1, camera1);
            controls2.update(); renderer2.render(scene2, camera2);
            controls3.update(); renderer3.render(scene3, camera3);
        }
        
        // --- Initialization ---
        window.addEventListener('resize', onWindowResize, false);
        init1();
        init2();
        init3();
        
        document.querySelectorAll('.viz-container').forEach(c => {
            originalSizes[c.dataset.id] = { width: c.clientWidth, height: c.clientHeight };
        });
        
        // Initial setup for contextual sliders
        const initialSliderVal = parseInt(maxVarianceSlider.value);
        MAX_VARIANCE = getLogVariance(initialSliderVal);
        const initialDisplayVal = MAX_VARIANCE > 1000 ? `${(MAX_VARIANCE/1000).toFixed(1)}k` : Math.round(MAX_VARIANCE);
        document.getElementById('maxVarianceDisplay').textContent = initialDisplayVal;

        switchShape('sphere');
        animate();
    </script>
</body>
</html>
