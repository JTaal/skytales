<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Neural Network Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #030712; color: #e5e7eb; overflow: hidden; }
        .ui-panel { background-color: rgba(17, 24, 39, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(55, 65, 81, 0.7); border-radius: 12px; }
        .control-btn, .preset-btn, .main-nav-btn { background-color: #374151; border: 1px solid #4b5563; transition: background-color 0.2s, transform 0.1s; border-radius: 6px; padding: 0.5rem 1rem; }
        .control-btn:hover, .preset-btn:hover, .main-nav-btn:hover { background-color: #4f46e5; }
        .control-btn:active, .preset-btn:active, .main-nav-btn:active { transform: translateY(1px); }
        .preset-btn.active, .main-nav-btn.active { background-color: #4f46e5; box-shadow: 0 0 10px rgba(79, 70, 229, 0.5); font-weight: 600; }
        select, input[type="text"] { background-color: #1f2937; border: 1px solid #4b5563; border-radius: 6px; padding: 0.5rem; width: 100%; }
        input[type="range"]{-webkit-appearance:none;width:100%;height:4px;background:#4b5563;border-radius:2px;outline:none}
        input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:#818cf8;cursor:pointer;border-radius:50%}
        .main-view { display: none; } .main-view.active { display: block; }
        header { position: fixed; top: 0; left: 0; right: 0; z-index: 20; display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; background-color: rgba(3, 7, 18, 0.5); backdrop-filter: blur(5px); border-bottom: 1px solid rgba(55, 65, 81, 0.7); height: 65px; }
        #settings-panel { position: fixed; top: 0; right: 0; width: 400px; max-width: 100vw; height: 100%; z-index: 30; padding: 1.5rem; transition: transform 0.3s ease-in-out; transform: translateX(100%); overflow-y: auto; }
        #settings-panel.open { transform: translateX(0); }
        #settings-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 29; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        #settings-backdrop.open { opacity: 1; pointer-events: auto; }
        .hidden { display: none !important; }
        
        #three-d-view { position: fixed; top: 65px; bottom: 85px; left: 0; right: 0; z-index: 0; }
        #three-canvas { cursor: grab; width:100%; height:100%;}
        #bottom-dock { position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); z-index: 20; padding: 0.75rem 1.5rem; margin-bottom: 1rem; height: 68px; }

        #builder-view { background-color: #030712; width: 100%; height: calc(100vh - 65px); margin-top: 65px; box-sizing: border-box; }
        #builder-svg { width: 100%; height: 100%; }
        #builder-svg .builder-node { cursor: pointer; transition: all 0.2s; }
        #builder-svg .builder-node:hover > circle { fill: #4f46e5; stroke: #a5b4fc; }
        #builder-svg .builder-node.io-node:hover > circle { fill: #16a34a; }
        #builder-svg .add-btn, #builder-svg .delete-btn { cursor: pointer; opacity: 0.7; transition: opacity 0.2s; }
        #builder-svg .add-btn:hover, #builder-svg .delete-btn:hover { opacity: 1; }
        .builder-select { background-color: #1f2937; border: 1px solid #4b5563; color: #e5e7eb; border-radius: 4px; font-family: 'Inter', sans-serif; }
        
        .accordion-header { cursor: pointer; user-select: none; }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
        .accordion-content.open { max-height: 500px; }
        .accordion-icon { transition: transform 0.3s ease-out; }
        .accordion-header.open .accordion-icon { transform: rotate(90deg); }
        .toggle-bg:after { content: ''; position: absolute; top: 2px; left: 2px; background: white; border-radius: 9999px; height: 1rem; width: 1rem; transition: transform 0.2s ease-in-out; }
        input:checked + .toggle-bg:after { transform: translateX(100%); transform: translateX(calc(1.75rem - 100%)); }
        input:checked + .toggle-bg { background-color: #4f46e5; }
    </style>
</head>
<body>
    <header>
        <div class="flex items-center gap-4">
             <h1 class="text-xl font-bold text-gray-200">NN Visualizer</h1>
             <div class="flex items-center gap-2 p-1 bg-gray-900 rounded-lg">
                 <button id="nav-builder" class="main-nav-btn text-sm py-1 px-3">Network Builder</button>
                 <button id="nav-trainer" class="main-nav-btn text-sm py-1 px-3 active">3D Training View</button>
             </div>
        </div>
        <div class="flex items-center gap-4">
            <button id="apply-architecture-btn" class="main-nav-btn active hidden">Apply & Train</button>
            <button id="settings-btn" class="control-btn"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg></button>
        </div>
    </header>
    
    <!-- Trainer View -->
    <div id="three-d-view" class="main-view active">
        <div id="three-canvas-container" class="w-full h-full"><canvas id="three-canvas"></canvas></div>
        <div id="bottom-dock" class="ui-panel flex items-center gap-6"><button id="play-pause-btn" class="control-btn flex items-center justify-center gap-2"><svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M8 5v14l11-7z"/></svg><svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="hidden"><path fill="currentColor" d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg><span id="play-pause-text">Play</span></button><div class="text-center text-sm text-gray-400">Epoch: <span id="epoch-counter" class="font-mono font-bold text-gray-200 text-base">0</span></div><button id="reset-btn" class="control-btn flex items-center justify-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg><span>Reset</span></button></div>
    </div>
    
    <!-- Builder View -->
    <div id="builder-view" class="main-view">
        <svg id="builder-svg"></svg>
    </div>

    <!-- Hidden Canvases for Chart Textures -->
    <div class="hidden">
        <canvas id="loss-canvas"></canvas>
        <canvas id="accuracy-canvas"></canvas>
    </div>

    <!-- Settings Panel -->
    <div id="settings-backdrop"></div>
    <div id="settings-panel" class="ui-panel">
        <div class="flex justify-between items-center border-b border-gray-700 pb-3 mb-4"><h2 class="text-xl font-bold text-indigo-400">Settings</h2><button id="close-settings-btn" class="control-btn p-2"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button></div>
        
        <div class="space-y-4">
            <div class="border-b border-gray-700 pb-4">
                 <div class="accordion-header flex justify-between items-center open">
                    <h3 class="font-semibold">Presets</h3>
                     <svg class="accordion-icon w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </div>
                <div class="accordion-content open space-y-4 pt-4">
                    <div><h4 class="font-medium text-sm mb-2">Network Presets</h4><div id="nn-presets" class="grid grid-cols-2 gap-2"><button class="preset-btn" data-preset="linear">Linear</button><button class="preset-btn" data-preset="xor">XOR Solver</button><button class="preset-btn" data-preset="moons">Moons Solver</button><button class="preset-btn" data-preset="spiral">Spiral Solver</button></div></div>
                    <div><h4 class="font-medium text-sm mb-2">Dataset Templates</h4><div id="dataset-presets" class="grid grid-cols-2 sm:grid-cols-3 gap-2"><button class="preset-btn" data-dataset="circle">Circle</button><button class="preset-btn" data-dataset="xor">XOR</button><button class="preset-btn" data-dataset="spiral">Spiral</button><button class="preset-btn" data-dataset="interleaved">Interleaved</button><button class="preset-btn" data-dataset="moons">Moons</button><button class="preset-btn" data-dataset="gaussian">Blobs</button><button class="preset-btn" data-dataset="ushape">U-Shape</button><button class="preset-btn" data-dataset="rings">Rings</button><button class="preset-btn" data-dataset="swiss_roll">Swiss Roll</button><button class="preset-btn" data-dataset="checkerboard">Checker</button></div></div>
                </div>
            </div>

            <div class="border-b border-gray-700 py-4">
                <div class="accordion-header flex justify-between items-center">
                    <h3 class="font-semibold">Custom Data</h3>
                    <svg class="accordion-icon w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </div>
                <div class="accordion-content space-y-3 pt-4">
                    <label for="api-url-input" class="font-medium text-sm">Load from API (URL)</label>
                    <input type="text" id="api-url-input" placeholder="e.g., https://api.example.com/data">
                    <button id="api-fetch-btn" class="control-btn w-full text-sm">Fetch & Apply</button>
                    <p id="api-status" class="text-xs text-center text-gray-400 h-4"></p>
                </div>
            </div>

            <div class="border-b border-gray-700 py-4">
                <div class="accordion-header flex justify-between items-center">
                    <h3 class="font-semibold">Training Parameters</h3>
                     <svg class="accordion-icon w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </div>
                <div class="accordion-content space-y-4 pt-4">
                    <div><label for="lr-slider" class="font-medium text-sm">Learning Rate: <span id="lr-value" class="font-mono">0.1</span></label><input id="lr-slider" type="range" min="0.0001" max="0.5" step="0.001" value="0.1"></div>
                    <div><label for="batch-size-slider" class="font-medium text-sm">Batch Size: <span id="batch-size-value" class="font-mono">10</span></label><input id="batch-size-slider" type="range" min="1" max="50" step="1" value="10"></div>
                </div>
            </div>

            <div class="border-b border-gray-700 py-4">
                <div class="accordion-header flex justify-between items-center open">
                    <h3 class="font-semibold">Display</h3>
                    <svg class="accordion-icon w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </div>
                <div class="accordion-content open space-y-4 pt-4">
                    <div class="flex items-center justify-between"><label for="charts-toggle-input" class="font-medium text-sm text-gray-300">Show Perf. Charts</label><label class="flex items-center cursor-pointer"><input type="checkbox" id="charts-toggle-input" class="sr-only" checked><div class="toggle-bg bg-gray-600 relative w-11 h-6 rounded-full"></div></label></div>
                    <div id="three-d-view-selector" class="flex items-center gap-2 p-1 bg-gray-900 rounded-lg"><button class="preset-btn text-sm py-2 px-3 w-full" data-view="output">Final Output</button><button class="preset-btn text-sm py-2 px-3 w-full" data-view="neuron">Single Neuron</button></div>
                    <div id="neuron-selector-container" class="flex items-center gap-2 text-sm mt-2 sm:mt-0 hidden"><label for="neuron-select">View Neuron:</label><select id="neuron-select" class="w-full"></select></div>
                </div>
            </div>

            <div class="border-b border-gray-700 py-4">
                <div class="accordion-header flex justify-between items-center">
                    <h3 class="font-semibold">Graphical Settings</h3>
                    <svg class="accordion-icon w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </div>
                <div class="accordion-content space-y-4 pt-4">
                     <div class="flex items-center justify-between"><label for="bloom-toggle-input" class="font-medium text-sm text-gray-300">Bloom Effect</label><label class="flex items-center cursor-pointer"><input type="checkbox" id="bloom-toggle-input" class="sr-only" checked><div class="toggle-bg bg-gray-600 relative w-11 h-6 rounded-full"></div></label></div>
                    <div><label for="plane-res-slider" class="font-medium text-sm">Plane Resolution: <span id="plane-res-value" class="font-mono">60</span></label><input id="plane-res-slider" type="range" min="10" max="100" step="1" value="60"></div>
                </div>
            </div>

            <div class="border-b border-gray-700 py-4">
                 <div class="accordion-header flex justify-between items-center">
                    <h3 class="font-semibold">Grid Settings</h3>
                    <svg class="accordion-icon w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </div>
                <div class="accordion-content space-y-4 pt-4">
                    <div class="flex items-center justify-between"><label for="grid-toggle-input" class="font-medium text-sm text-gray-300">Show Grid</label><label class="flex items-center cursor-pointer"><input type="checkbox" id="grid-toggle-input" class="sr-only" checked><div class="toggle-bg bg-gray-600 relative w-11 h-6 rounded-full"></div></label></div>
                    <div><label for="grid-opacity-slider" class="font-medium text-sm">Grid Opacity: <span id="grid-opacity-value" class="font-mono">0.2</span></label><input id="grid-opacity-slider" type="range" min="0" max="1" step="0.05" value="0.2"></div>
                </div>
            </div>

            <div class="pt-4">
                 <div class="accordion-header flex justify-between items-center">
                    <h3 class="font-semibold">Data Settings</h3>
                    <svg class="accordion-icon w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </div>
                <div class="accordion-content space-y-4 pt-4">
                    <div><label for="data-size-slider" class="font-medium text-sm">Data Point Size: <span id="data-size-value" class="font-mono">1.0</span></label><input id="data-size-slider" type="range" min="0.25" max="2.5" step="0.05" value="1.0"></div>
                </div>
            </div>
        </div>
    </div>
    
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- STATE & CONFIG ---
    let nn_state = { isTraining: false, learningRate: 0.03, batchSize: 10, currentDataset: 'circle', networkArchitecture: [2, 2], activations: ['softmax'], epoch: 0, rafId: null };
    let builder_state = { architecture: [2, 4, 2], activations: ['relu', 'softmax'] };
    let graphics_state = { showCharts: true, planeResolution: 60, showGrid: true, gridOpacity: 0.2, pointSize: 1.0, useBloom: true };
    let threeState = { selectedNeuron: 0, viewMode: 'output' };
    let network, trainX, trainY, lossChart, accuracyChart;
    
    // --- 3D SCENE & NN IMPLEMENTATION ---
    let threeScene, threeCamera, threeRenderer, threeControls, planeMesh, dataPointsObject, weightVectorHelper, biasPlaneHelper, gridHelper;
    let lossChartPlane, accuracyChartPlane, composer, bloomPass;

    const ACTIVATION_FUNCTIONS = {
        relu: { func: (x) => Math.max(0, x), derivative: (x) => x > 0 ? 1 : 0, formula: "y = max(0, x)" },
        tanh: { func: (x) => Math.tanh(x), derivative: (x) => 1 - Math.pow(Math.tanh(x), 2), formula: "y = tanh(x)" },
        sigmoid: { func: (x) => 1 / (1 + Math.exp(-x)), derivative: (x) => { const s = 1 / (1 + Math.exp(-x)); return s * (1 - s); }, formula: "y = 1 / (1 + e⁻ˣ)" },
        softmax: { isOutput: true, formula: "softmax" }
    };

    const ACTIVATION_PATHS = {
        relu: "M-8,5 L0,5 L8,-5",
        tanh: "M-8,8 C-4,8 4,-8 8,-8",
        sigmoid: "M-8,8 C-4,8 4,0 8,0"
    };
    
    function initThreeJS() {
        const container = document.getElementById('three-canvas-container');
        threeScene = new THREE.Scene();
        threeCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 100);
        threeCamera.position.set(0, 2.2, 4);
        threeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, canvas: document.getElementById('three-canvas') });
        threeRenderer.setPixelRatio(window.devicePixelRatio);
        threeRenderer.setSize(container.clientWidth, container.clientHeight);
        
        threeControls = new OrbitControls(threeCamera, threeRenderer.domElement);
        threeControls.enableDamping = true;
        threeScene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(2, 3, 2);
        threeScene.add(dirLight);

        const renderScene = new RenderPass(threeScene, threeCamera);
        bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 0.5;
        bloomPass.radius = 0;
        composer = new EffectComposer(threeRenderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const planeGeom = new THREE.PlaneGeometry(2.5, 2.5, graphics_state.planeResolution, graphics_state.planeResolution);
        const planeMat = new THREE.MeshStandardMaterial({ vertexColors: true, side: THREE.DoubleSide, metalness: 0.2, roughness: 0.8 });
        planeMesh = new THREE.Mesh(planeGeom, planeMat);
        planeMesh.rotation.x = -Math.PI / 2;
        threeScene.add(planeMesh);
        
        dataPointsObject = new THREE.Group();
        threeScene.add(dataPointsObject);

        gridHelper = new THREE.GridHelper(10, 10, 0x4b5563, 0x4b5563);
        gridHelper.material.opacity = graphics_state.gridOpacity;
        gridHelper.material.transparent = true;
        threeScene.add(gridHelper);

        weightVectorHelper = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1.2, 0xffff00, 0.1, 0.05);
        weightVectorHelper.visible = false;
        threeScene.add(weightVectorHelper);

        const biasPlaneGeom = new THREE.PlaneGeometry(3, 3);
        const biasPlaneMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
        biasPlaneHelper = new THREE.Mesh(biasPlaneGeom, biasPlaneMat);
        biasPlaneHelper.visible = false;
        threeScene.add(biasPlaneHelper);

        const animate = () => { requestAnimationFrame(animate); threeControls.update(); composer.render(); };
        animate();
        
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                 if (width > 0 && height > 0) {
                     threeCamera.aspect = width / height;
                     threeCamera.updateProjectionMatrix();
                     threeRenderer.setSize(width, height);
                     composer.setSize(width, height);
                 }
            }
        });
        resizeObserver.observe(container);
    }
    
    function update3DScene() {
        if (!planeMesh || !network) return;
        const positions = planeMesh.geometry.attributes.position;
        const colors = planeMesh.geometry.attributes.color || new THREE.BufferAttribute(new Float32Array(positions.count * 3), 3);
        const colorClass0 = new THREE.Color('#4f46e5'), colorClass1 = new THREE.Color('#16a34a');

        if (threeState.viewMode === 'output') {
             for (let i = 0; i < positions.count; i++) {
                 const x_in = positions.getX(i), y_in = positions.getY(i);
                 const probClass0 = network.predict([x_in, -y_in])[0];
                 positions.setZ(i, (probClass0 - 0.5) * 2);
                 const color = colorClass0.clone().lerp(colorClass1, 1 - probClass0);
                 colors.setXYZ(i, color.r, color.g, color.b);
             }
        } else {
            const firstHiddenLayer = network.layers[0];
            const neuronIndex = threeState.selectedNeuron;
            if (!firstHiddenLayer || firstHiddenLayer.activation.isOutput || neuronIndex >= firstHiddenLayer.biases.length) return;
            const { weights, biases, activation } = firstHiddenLayer;
            for (let i = 0; i < positions.count; i++) {
                const x_in = positions.getX(i), y_in = positions.getY(i);
                const z_pre = weights[0][neuronIndex] * x_in + weights[1][neuronIndex] * (-y_in) + biases[neuronIndex];
                positions.setZ(i, activation.func(z_pre));
                const color = z_pre > 0 ? colorClass0 : colorClass1;
                const intensity = Math.min(1, Math.abs(z_pre) * 0.8);
                colors.setXYZ(i, color.r * intensity, color.g * intensity, color.b * intensity);
            }
            const weightVec = new THREE.Vector3(weights[0][neuronIndex], weights[1][neuronIndex], 0);
            const weightLen = weightVec.length() || 1;
            weightVec.normalize();
            weightVectorHelper.setDirection(new THREE.Vector3(weightVec.x, 0, weightVec.y));
            weightVectorHelper.setLength(Math.min(1.2, weightLen * 0.5));
            const dist = -biases[neuronIndex] / weightLen;
            biasPlaneHelper.position.set(dist * weightVec.x, 0, dist * weightVec.y);
            biasPlaneHelper.lookAt(weightVec.x, 0, weightVec.y);
        }
        positions.needsUpdate = true;
        colors.needsUpdate = true;
        planeMesh.geometry.setAttribute('color', colors);
        planeMesh.geometry.computeVertexNormals();
        updateDataPoints3D();
    }
    
    function updateDataPoints3D() {
        dataPointsObject.children.forEach(child => {
            const { x_in, y_in } = child.userData;
            if (threeState.viewMode === 'output') {
                child.position.y = (network.predict([x_in, y_in])[0] - 0.5) * 2 + 0.05;
            } else {
                 if (network.layers.length > 0 && !network.layers[0].activation.isOutput && network.layers[0].biases.length > threeState.selectedNeuron) {
                     child.position.y = network.getNeuronActivation([x_in, y_in], 0, threeState.selectedNeuron) + 0.05;
                 }
            }
        });
    }

    class NeuralNetwork {
        constructor(arch, acts) { this.layers = []; this.activations = acts.map(a => ACTIVATION_FUNCTIONS[a]); for (let i = 0; i < arch.length - 1; i++) { this.layers.push({ weights: Array.from({ length: arch[i] }, () => Array.from({ length: arch[i+1] }, () => Math.random() * 0.2 - 0.1)), biases: Array(arch[i+1]).fill(0), activation: this.activations[i] }); } }
        forward(inputs) { let current = inputs; const all_activations = [inputs]; const all_pre_activations = []; for (const l of this.layers) { const pre_act = Array(l.biases.length).fill(0).map((_,j) => l.biases[j] + current.reduce((s,val,i) => s + val*l.weights[i][j], 0)); all_pre_activations.push(pre_act); if (l.activation.isOutput) { const max = Math.max(...pre_act); const exps = pre_act.map(o => Math.exp(o - max)); const sum = exps.reduce((a, b) => a + b, 0); current = exps.map(e => e / (sum || 1)); } else { current = pre_act.map(o => l.activation.func(o)); } all_activations.push(current); } return { final: current, all: all_activations, pre: all_pre_activations }; }
        predict(inputs) { return this.forward(inputs).final; }
        getNeuronActivation(inputs, layerIdx, neuronIdx) { let c=inputs; for(let i=0;i<layerIdx;i++) c=this.layers[i].biases.map((_,j)=>this.layers[i].activation.func(this.layers[i].biases[j]+c.reduce((s,v,k)=>s+v*this.layers[i].weights[k][j],0))); return this.layers[layerIdx].activation.func(this.layers[layerIdx].biases[neuronIdx]+c.reduce((s,v,i)=>s+v*this.layers[layerIdx].weights[i][neuronIdx],0)); }
        train(batchX, batchY) { const grads=this.layers.map(l=>({weights:l.weights.map(r=>r.map(()=>0)),biases:l.biases.map(()=>0)})); for(let i=0;i<batchX.length;i++){ const x=batchX[i], y=batchY[i]; const {final,all,pre}=this.forward(x); let errors=[...final]; errors[y]-=1; for(let l=this.layers.length-1;l>=0;l--){ const layer=this.layers[l]; const prev_acts=all[l]; const pre_acts=pre[l]; if(!layer.activation.isOutput)errors=errors.map((e,j)=>e*layer.activation.derivative(pre_acts[j])); const next_errors=Array(prev_acts.length).fill(0); for(let j=0;j<errors.length;j++){ for(let k=0;k<prev_acts.length;k++){ grads[l].weights[k][j]+=prev_acts[k]*errors[j]; next_errors[k]+=layer.weights[k][j]*errors[j]; } grads[l].biases[j]+=errors[j]; } errors=next_errors; } } for(let l=0;l<this.layers.length;l++){for(let i=0;i<this.layers[l].weights.length;i++){for(let j=0;j<this.layers[l].weights[i].length;j++){this.layers[l].weights[i][j]-=nn_state.learningRate*(grads[l].weights[i][j]/batchX.length)}}for(let i=0;i<this.layers[l].biases.length;i++){this.layers[l].biases[i]-=nn_state.learningRate*(grads[l].biases[i]/batchX.length)}} }
    }
    function normalizeData(data, labels) { const xs=data.map(d=>d[0]), ys=data.map(d=>d[1]); const xMin=Math.min(...xs), xMax=Math.max(...xs), yMin=Math.min(...ys), yMax=Math.max(...ys); const range=Math.max(xMax-xMin,yMax-yMin)||1; return { data: data.map(([x,y])=>[(x-(xMin+xMax)/2)/range*2.5,(y-(yMin+yMax)/2)/range*2.5]), labels }; }
    function generateCircleData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const r=i<n/2?Math.random()*2:Math.random()*2+2.5; const a=Math.random()*2*Math.PI; data.push([r*Math.sin(a),r*Math.cos(a)]);labels.push(i<n/2?0:1); } return normalizeData(data,labels); }
    function generateXORData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const x=Math.random()*2-1, y=Math.random()*2-1; data.push([x,y]); labels.push((x>0&&y>0)||(x<0&&y<0)?0:1); } return normalizeData(data,labels); }
    function generateSpiralData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const r=(i% (n/2))/(n/2)*5; const a=1.75*(i%(n/2))/(n/2)*2*Math.PI+(i<n/2?0:Math.PI); data.push([r*Math.sin(a),r*Math.cos(a)]); labels.push(i<n/2?0:1); } return normalizeData(data,labels); }
    function generateInterleavedData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const x=Math.random()*2-1, y=Math.random()*2-1; data.push([x,y]); labels.push(Math.sin(5*x)>y?0:1); } return normalizeData(data,labels); }
    function generateMoonsData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const m=i<n/2, a=Math.PI*Math.random(), r=m?1:-1; data.push([r*Math.cos(a)+(m?0:1),r*Math.sin(a)+(m?0:0.3)]); labels.push(m?0:1); } return normalizeData(data,labels); }
    function generateGaussianData(n=200){ const data=[],labels=[], c=[[-1.5,1.5],[1.5,-1.5]]; for(let i=0;i<n;i++){ const s=c[i<n/2?0:1]; data.push([s[0]+(Math.random()-0.5)*1.5,s[1]+(Math.random()-0.5)*1.5]); labels.push(i<n/2?0:1); } return normalizeData(data,labels); }
    function generateUshapeData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const isU=i<n*0.7; let x,y; if(isU){const a=Math.PI+Math.random()*Math.PI;x=2*Math.cos(a);y=2*Math.sin(a)}else{x=Math.random()*4-2;y=Math.random()*2-1.5} data.push([x,y]); labels.push(isU?0:1); } return normalizeData(data,labels); }
    function generateRingsData(n=250){ const data=[],labels=[]; for(let i=0;i<n;i++){ let r, l; if(i < n/2) { r=Math.random()*1.5+0.5; l=0; } else { r=Math.random()*1.5+3; l=1; } const a=Math.random()*2*Math.PI; data.push([r*Math.sin(a),r*Math.cos(a)]);labels.push(l); } return normalizeData(data,labels); }
    function generateSwissRollData(n=250){ const data=[],labels=[]; for(let i=0;i<n;i++){ const t=1.5*Math.PI*(1+2*Math.random()); const y=10*Math.random(); data.push([t*Math.cos(t),t*Math.sin(t)]); labels.push(y>5?0:1); } return normalizeData(data,labels); }
    function generateCheckerboardData(n=250){ const data=[],labels=[]; for(let i=0;i<n;i++){ const x=Math.random()*8-4; const y=Math.random()*8-4; data.push([x,y]); labels.push((Math.floor(x)%2===0)^(Math.floor(y)%2===0)?0:1); } return normalizeData(data,labels); }
    const DATASETS = { circle: generateCircleData, xor: generateXORData, spiral: generateSpiralData, interleaved: generateInterleavedData, moons: generateMoonsData, gaussian: generateGaussianData, ushape: generateUshapeData, rings: generateRingsData, swiss_roll: generateSwissRollData, checkerboard: generateCheckerboardData };
    const NN_PRESETS = { linear:{dataset:'circle',architecture:[2,2],activations:['softmax']}, xor:{dataset:'xor',architecture:[2,4,2],activations:['relu','softmax']}, moons:{dataset:'moons',architecture:[2,8,2],activations:['tanh','softmax']}, spiral:{dataset:'spiral',architecture:[2,8,8,2],activations:['tanh','tanh','softmax']} };
    
    function updateAllVisualizations() {
        requestAnimationFrame(() => {
            update3DScene();
        });
    }

    function trainingStep() {
        const batchIndices = Array.from({length: nn_state.batchSize}, () => Math.floor(Math.random() * trainX.length));
        const batchX = batchIndices.map(i => trainX[i]);
        const batchY = batchIndices.map(i => trainY[i]);
        network.train(batchX, batchY);
        
        if (nn_state.epoch % 10 === 0) {
            let correct = 0;
            let totalEpochLoss = 0;
            trainX.forEach((x, i) => {
                const predictionProbs = network.predict(x);
                const correctClassProb = predictionProbs[trainY[i]];
                totalEpochLoss -= Math.log(correctClassProb + 1e-9);
                if (predictionProbs.indexOf(Math.max(...predictionProbs)) === trainY[i]) {
                    correct++;
                }
            });
            const accuracy = correct / trainX.length;
            const averageEpochLoss = totalEpochLoss / trainX.length;
            updateCharts(nn_state.epoch, averageEpochLoss, accuracy);
        }
        if (nn_state.epoch % 5 === 0) updateAllVisualizations();
        
        document.getElementById('epoch-counter').textContent = nn_state.epoch;
        nn_state.epoch++;
        if (nn_state.isTraining) nn_state.rafId = requestAnimationFrame(trainingStep);
    }
    
    function toggleTraining() {
        nn_state.isTraining = !nn_state.isTraining;
        document.getElementById('play-icon').classList.toggle('hidden', nn_state.isTraining);
        document.getElementById('pause-icon').classList.toggle('hidden', !nn_state.isTraining);
        document.getElementById('play-pause-text').textContent = nn_state.isTraining ? 'Pause' : 'Play';
        if (nn_state.isTraining) trainingStep();
        else cancelAnimationFrame(nn_state.rafId);
    }

    function fullResetNN(customData = null) {
        if(nn_state.isTraining) toggleTraining();
        nn_state.epoch = 0;
        const { data, labels } = customData ? customData : DATASETS[nn_state.currentDataset]();
        trainX = data; trainY = labels;
        const outputSize = Math.max(...labels) + 1;
        
        nn_state.networkArchitecture = [...builder_state.architecture];
        nn_state.networkArchitecture[nn_state.networkArchitecture.length - 1] = outputSize;
        nn_state.activations = [...builder_state.activations];
        
        network = new NeuralNetwork(nn_state.networkArchitecture, nn_state.activations);
        
        if (lossChart) {
             lossChart.data.labels = []; lossChart.data.datasets[0].data = [];
             accuracyChart.data.labels = []; accuracyChart.data.datasets[0].data = [];
             lossChart.update(); accuracyChart.update();
        }

        document.getElementById('epoch-counter').textContent = 0;
        if (!customData) {
            document.querySelectorAll('#dataset-presets button').forEach(b => b.classList.toggle('active', b.dataset.dataset === nn_state.currentDataset));
        } else {
            document.querySelectorAll('#dataset-presets button').forEach(b => b.classList.remove('active'));
        }
        populateNeuronSelector();
        
        dataPointsObject.clear();
        const pointGeom = new THREE.SphereGeometry(0.04, 16, 16);
        const matClass0 = new THREE.MeshBasicMaterial({color: 0x6366f1});
        const matClass1 = new THREE.MeshBasicMaterial({color: 0x22c55e});
        trainX.forEach((p, i) => {
            const point = new THREE.Mesh(pointGeom, trainY[i] === 0 ? matClass0 : matClass1);
            point.position.set(p[0], 0.05, p[1]);
            point.userData = { x_in: p[0], y_in: p[1] };
            point.scale.set(graphics_state.pointSize, graphics_state.pointSize, graphics_state.pointSize);
            dataPointsObject.add(point);
        });
        updateAllVisualizations();
    }
    
    function applyNNPreset(presetKey) {
        if(nn_state.isTraining) toggleTraining();
        const preset = NN_PRESETS[presetKey];
        nn_state.currentDataset = preset.dataset;
        builder_state.architecture = [...preset.architecture];
        builder_state.activations = [...preset.activations];
        document.querySelectorAll('#nn-presets button').forEach(b => b.classList.remove('active'));
        document.querySelector(`#nn-presets button[data-preset="${presetKey}"]`).classList.add('active');
        fullResetNN();
    }
    
    function setupCharts() {
        const chartOptions = (title) => ({
            responsive: false, maintainAspectRatio: false, animation: false,
            scales: { 
                y: { 
                    beginAtZero: true, 
                    ticks:{ color:'#e5e7eb', font: {size: 24} }, 
                    grid: { display: false },
                    border: { display: false }
                }, 
                x: { 
                    ticks:{ display:false }, 
                    grid: { display: false },
                    border: { display: false }
                } 
            },
            plugins: {
                legend: { display: false },
                title: { display: true, text: title, color: '#e5e7eb', font: { size: 28 } },
                beforeDraw: (chart) => {
                    const ctx = chart.canvas.getContext('2d');
                    ctx.clearRect(0, 0, chart.width, chart.height);
                }
            },
            layout: { padding: 20 }
        });
        
        const lossCanvas = document.getElementById('loss-canvas');
        lossCanvas.width = 800; lossCanvas.height = 500;
        lossChart = new Chart(lossCanvas.getContext('2d'), { type: 'line', data: { labels: [], datasets: [{ label: 'Loss', data: [], borderColor: '#f87171', borderWidth: 2, tension: 0.1, pointRadius: 0 }] }, options: chartOptions("Training Loss") });

        const accCanvas = document.getElementById('accuracy-canvas');
        accCanvas.width = 800; accCanvas.height = 500;
        const accChartOptions = chartOptions("Accuracy");
        accChartOptions.scales.y.min = 0;
        accChartOptions.scales.y.max = 1;
        accuracyChart = new Chart(accCanvas.getContext('2d'), { type: 'line', data: { labels: [], datasets: [{ label: 'Accuracy', data: [], borderColor: '#4ade80', borderWidth: 2, tension: 0.1, pointRadius: 0 }] }, options: accChartOptions });

        lossChartPlane = createChartPlane(lossCanvas, new THREE.Vector3(-2.5, 1.2, -1.8));
        lossChartPlane.rotation.y = Math.PI / 9;
        accuracyChartPlane = createChartPlane(accCanvas, new THREE.Vector3(2.5, 1.2, -1.8));
        accuracyChartPlane.rotation.y = -Math.PI / 9;
    }

    function createChartPlane(canvas, position) {
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
        const geometry = new THREE.PlaneGeometry(2.4, 1.5);
        const plane = new THREE.Mesh(geometry, material);
        plane.position.copy(position);
        plane.visible = graphics_state.showCharts;
        threeScene.add(plane);
        return plane;
    }
    
    function updateCharts(epoch, loss, accuracy) {
        if (!lossChart || !accuracyChart) return;
        lossChart.data.labels.push(epoch);
        lossChart.data.datasets[0].data.push(loss);
        accuracyChart.data.labels.push(epoch);
        accuracyChart.data.datasets[0].data.push(accuracy);
        
        lossChart.update('none');
        accuracyChart.update('none');

        lossChartPlane.material.map.needsUpdate = true;
        accuracyChartPlane.material.map.needsUpdate = true;
    }

    function populateNeuronSelector() {
        const selector = document.getElementById('neuron-select');
        selector.innerHTML = '';
        if(nn_state.networkArchitecture.length < 3) return;
        const numNeurons = nn_state.networkArchitecture[1];
        if (numNeurons) {
            for (let i = 0; i < numNeurons; i++) {
                const option = document.createElement('option');
                option.value = i; option.textContent = `Hidden 1, Neuron ${i+1}`;
                selector.appendChild(option);
            }
        }
        selector.value = threeState.selectedNeuron < numNeurons ? threeState.selectedNeuron : 0;
    }
    
    async function fetchAndApplyAPIData() {
        const url = document.getElementById('api-url-input').value;
        const statusEl = document.getElementById('api-status');
        if (!url) {
            statusEl.textContent = "Please enter a URL.";
            return;
        }
        statusEl.textContent = "Fetching...";
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const jsonData = await response.json();

            if (!jsonData.data || !jsonData.labels || !Array.isArray(jsonData.data) || !Array.isArray(jsonData.labels) || jsonData.data.length !== jsonData.labels.length) {
                throw new Error("Invalid data format.");
            }
            
            statusEl.textContent = "Data loaded successfully!";
            const normalizedData = normalizeData(jsonData.data, jsonData.labels);
            fullResetNN(normalizedData);

        } catch (error) {
            console.error("API Fetch Error:", error);
            statusEl.textContent = `Error: ${error.message}`;
        } finally {
            setTimeout(() => { statusEl.textContent = ""; }, 3000);
        }
    }

    function renderBuilder() {
        const svg = d3.select("#builder-svg");
        svg.selectAll("*").remove();
        const { width, height } = svg.node().getBoundingClientRect();
        if (width === 0) return;

        const arch = builder_state.architecture;
        const layerCount = arch.length;
        
        const maxLayerWidth = 150;
        const minGap = 20;
        let effectiveLayerWidth = Math.min(maxLayerWidth, (width - (layerCount + 1) * minGap) / layerCount);
        let layerGap = (width - layerCount * effectiveLayerWidth) / (layerCount + 1);

        const layersData = arch.map((size, i) => Array.from({ length: size }, (_, j) => ({ layer: i, neuron: j, size: size })));
        
        const nodes = layersData.flat();
        nodes.forEach(n => {
            n.x = layerGap + effectiveLayerWidth / 2 + n.layer * (effectiveLayerWidth + layerGap);
            n.y = (n.neuron + 1) * (height-120) / (n.size + 1) + 60;
        });

        const links = [];
        for (let i = 0; i < layerCount - 1; i++) {
            for (let j = 0; j < layersData[i].length; j++) {
                for (let k = 0; k < layersData[i+1].length; k++) {
                    links.push({ source: nodes.find(n => n.layer === i && n.neuron === j), target: nodes.find(n => n.layer === i + 1 && n.neuron === k) });
                }
            }
        }

        svg.append("g").selectAll("path").data(links).join("path").attr("d", d => `M${d.source.x},${d.source.y} L${d.target.x},${d.target.y}`).attr("stroke", "#4b5563").attr("stroke-width", 1.5);
        
        const layerGroups = svg.selectAll("g.layer-group").data(layersData).join("g");
        
        layerGroups.append("rect")
            .attr("x", d => layerGap + d[0].layer * (effectiveLayerWidth + layerGap))
            .attr("y", 20)
            .attr("width", effectiveLayerWidth)
            .attr("height", height - 40)
            .attr("fill", "rgba(31, 41, 55, 0.5)")
            .attr("stroke", "#4b5563")
            .attr("stroke-width", 1)
            .attr("rx", 12);

        layerGroups.append("text").attr("x", d => layerGap + effectiveLayerWidth / 2 + d[0].layer * (effectiveLayerWidth + layerGap)).attr("y", 45).attr("text-anchor", "middle").attr("font-size", "14px").attr("font-weight", "600").attr("fill", "#9ca3af").text((d, i) => i === 0 ? "Input" : i === layerCount - 1 ? "Output" : `Hidden ${i}`);

        const nodeGroups = svg.selectAll("g.builder-node").data(nodes).join("g").attr("class", d => `builder-node ${d.layer === 0 || d.layer === layerCount - 1 ? 'io-node' : ''}`).attr("transform", d => `translate(${d.x},${d.y})`).on("mouseover", function(e, d) { if (d.layer > 0 && d.layer < layerCount - 1 && arch[d.layer] > 1) { const g = d3.select(this).append("g").attr("class", "delete-btn"); g.append("circle").attr("r", 8).attr("fill", "#ef4444"); g.append("text").text("-").attr("fill", "white").attr("text-anchor", "middle").attr("dy", ".35em").style("font-weight", "bold"); g.on("click", (e, d) => { e.stopPropagation(); builder_state.architecture[d.layer]--; renderBuilder(); }); } }).on("mouseout", function() { d3.select(this).select(".delete-btn").remove(); });
        
        nodeGroups.append("circle").attr("r", 15).attr("fill", d => (d.layer === 0 || d.layer === layerCount-1) ? "#10b981" : "#283142").attr("stroke", "#4b5563").attr("stroke-width", 2);

        const hiddenNodeGroups = nodeGroups.filter(d => d.layer > 0 && d.layer < layerCount - 1);
        hiddenNodeGroups.append("path")
            .attr("d", d => ACTIVATION_PATHS[builder_state.activations[d.layer-1]])
            .attr("stroke", "#a5b4fc")
            .attr("stroke-width", 1.5)
            .attr("fill", "none");

        const hiddenLayersData = layersData.slice(1, -1);
        const addNeuronButtons = svg.selectAll("g.add-neuron-btn").data(hiddenLayersData.filter(d => d.length < 8)).enter().append("g").attr("class", "add-btn").attr("transform", d => `translate(${layerGap + effectiveLayerWidth/2 + d[0].layer * (effectiveLayerWidth + layerGap)}, ${(d.length + 1) * (height-120) / (d.length + 2) + 60})`).on("click", (e, d) => { if (builder_state.architecture[d[0].layer] < 8) { builder_state.architecture[d[0].layer]++; renderBuilder(); } });
        addNeuronButtons.append("circle").attr("r", 10).attr("fill", "#374151").attr("stroke", "#4b5563").attr("stroke-width", 1.5);
        addNeuronButtons.append("text").text("+").attr("fill", "#e5e7eb").attr("text-anchor", "middle").attr("dy", ".35em").style("font-size", "14px").style("font-weight", "bold");

        if (layerCount - 2 < 4) {
             const addLayerBtn = svg.selectAll("g.add-layer-btn").data(d3.range(layerCount - 1)).enter()
                .append("g")
                .attr("class", "add-btn")
                .attr("transform", (d, i) => `translate(${(i + 1) * (effectiveLayerWidth + layerGap) + layerGap/2}, ${height / 2})`)
                .on("click", (e, i) => { if (builder_state.architecture.length - 2 < 4) { builder_state.architecture.splice(i + 1, 0, 4); builder_state.activations.splice(i, 0, 'relu'); renderBuilder(); } });
            addLayerBtn.append("circle").attr("r", 15).attr("fill", "#374151").attr("stroke", "#6b7280").attr("stroke-width", 2).style("stroke-dasharray", "3 3");
            addLayerBtn.append("text").text("+").attr("fill", "#9ca3af").attr("text-anchor", "middle").attr("dy", ".35em").style("font-size", "20px");
        }

        const hiddenLayerGroups = layerGroups.filter((d, i) => i > 0 && i < layerCount - 1);

        hiddenLayerGroups.append("text")
            .attr("class", "delete-btn")
            .attr("x", d => layerGap + effectiveLayerWidth - 15 + d[0].layer * (effectiveLayerWidth + layerGap))
            .attr("y", 45)
            .attr("text-anchor", "middle")
            .attr("font-size", "20px")
            .attr("fill", "#ef4444")
            .text("✕")
            .on("click", (e, d) => {
                const layerIndex = d[0].layer;
                if (builder_state.architecture.length > 2) {
                    builder_state.architecture.splice(layerIndex, 1);
                    builder_state.activations.splice(layerIndex - 1, 1);
                    renderBuilder();
                }
            });

        hiddenLayerGroups.append("foreignObject")
            .attr("x", d => layerGap + 10 + d[0].layer * (effectiveLayerWidth + layerGap))
            .attr("y", height - 65)
            .attr("width", effectiveLayerWidth - 20)
            .attr("height", 30)
            .html((d, i) => {
                const activation = builder_state.activations[i];
                let options = `<option value="relu" ${activation === 'relu' ? 'selected' : ''}>ReLU</option>`;
                options += `<option value="tanh" ${activation === 'tanh' ? 'selected' : ''}>Tanh</option>`;
                options += `<option value="sigmoid" ${activation === 'sigmoid' ? 'selected' : ''}>Sigmoid</option>`;
                return `<select class="builder-select w-full h-full text-center" onchange="(function(e, i){ this.builder_state.activations[i] = e.target.value; this.renderBuilder(); }).call(window, event, ${i})">${options}</select>`;
            });

        hiddenLayerGroups.append("text")
             .attr("x", d => layerGap + effectiveLayerWidth/2 + d[0].layer * (effectiveLayerWidth + layerGap))
             .attr("y", height - 80)
             .attr("text-anchor", "middle")
             .attr("font-family", "monospace")
             .attr("font-size", "12px")
             .attr("fill", "#818cf8")
             .text((d, i) => ACTIVATION_FUNCTIONS[builder_state.activations[i]].formula);
    }

    // --- INIT & BINDINGS ---
    initThreeJS();
    setupCharts();
    window.renderBuilder = renderBuilder;
    window.builder_state = builder_state;
    
    document.getElementById('settings-btn').addEventListener('click', () => { document.getElementById('settings-panel').classList.add('open'); document.getElementById('settings-backdrop').classList.add('open'); });
    const closeSettings = () => { document.getElementById('settings-panel').classList.remove('open'); document.getElementById('settings-backdrop').classList.remove('open'); };
    document.getElementById('close-settings-btn').addEventListener('click', closeSettings);
    document.getElementById('settings-backdrop').addEventListener('click', closeSettings);
    
    document.getElementById('play-pause-btn').addEventListener('click', toggleTraining);
    document.getElementById('reset-btn').addEventListener('click', () => fullResetNN());
    document.getElementById('api-fetch-btn').addEventListener('click', fetchAndApplyAPIData);
    
    document.getElementById('three-d-view-selector').addEventListener('click', (e) => { 
        if (e.target.tagName === 'BUTTON') { 
            threeState.viewMode = e.target.dataset.view; 
            document.querySelectorAll('#three-d-view-selector button').forEach(b => b.classList.remove('active')); 
            e.target.classList.add('active'); 
            document.getElementById('neuron-selector-container').classList.toggle('hidden', threeState.viewMode !== 'neuron'); 
            weightVectorHelper.visible = biasPlaneHelper.visible = (threeState.viewMode === 'neuron'); 
            update3DScene(); 
        } 
    });

    document.getElementById('nn-presets').addEventListener('click', e => { if (e.target.tagName === 'BUTTON') { applyNNPreset(e.target.dataset.preset); } });
    document.getElementById('dataset-presets').addEventListener('click', e => { if (e.target.tagName === 'BUTTON') { nn_state.currentDataset = e.target.dataset.dataset; fullResetNN(); } });
    document.getElementById('lr-slider').addEventListener('input', e => { nn_state.learningRate = parseFloat(e.target.value); document.getElementById('lr-value').textContent = nn_state.learningRate.toFixed(3); });
    document.getElementById('batch-size-slider').addEventListener('input', e => { nn_state.batchSize = parseInt(e.target.value); document.getElementById('batch-size-value').textContent = nn_state.batchSize; });
    document.getElementById('neuron-select').addEventListener('change', e => { threeState.selectedNeuron = parseInt(e.target.value); update3DScene(); });
    
    document.querySelectorAll('.accordion-header').forEach(header => {
        header.addEventListener('click', () => {
            const content = header.nextElementSibling;
            header.classList.toggle('open');
            content.classList.toggle('open');
        });
    });

    document.getElementById('charts-toggle-input').addEventListener('change', e => {
        graphics_state.showCharts = e.target.checked;
        if (lossChartPlane) lossChartPlane.visible = graphics_state.showCharts;
        if (accuracyChartPlane) accuracyChartPlane.visible = graphics_state.showCharts;
    });
    
    document.getElementById('bloom-toggle-input').addEventListener('change', e => {
        graphics_state.useBloom = e.target.checked;
        bloomPass.enabled = graphics_state.useBloom;
    });

    document.getElementById('plane-res-slider').addEventListener('input', e => {
        const res = parseInt(e.target.value);
        graphics_state.planeResolution = res;
        document.getElementById('plane-res-value').textContent = res;
        planeMesh.geometry.dispose();
        planeMesh.geometry = new THREE.PlaneGeometry(2.5, 2.5, res, res);
        update3DScene();
    });

    document.getElementById('grid-toggle-input').addEventListener('change', e => {
        graphics_state.showGrid = e.target.checked;
        gridHelper.visible = graphics_state.showGrid;
    });

    document.getElementById('grid-opacity-slider').addEventListener('input', e => {
        const opacity = parseFloat(e.target.value);
        graphics_state.gridOpacity = opacity;
        document.getElementById('grid-opacity-value').textContent = opacity.toFixed(2);
        gridHelper.material.opacity = opacity;
    });

    document.getElementById('data-size-slider').addEventListener('input', e => {
        const scale = parseFloat(e.target.value);
        graphics_state.pointSize = scale;
        document.getElementById('data-size-value').textContent = scale.toFixed(2);
        dataPointsObject.children.forEach(child => child.scale.set(scale, scale, scale));
    });

    function switchView(viewName) {
        document.getElementById('three-d-view').classList.toggle('active', viewName === 'trainer');
        document.getElementById('builder-view').classList.toggle('active', viewName === 'builder');
        document.getElementById('nav-trainer').classList.toggle('active', viewName === 'trainer');
        document.getElementById('nav-builder').classList.toggle('active', viewName === 'builder');
        document.getElementById('apply-architecture-btn').classList.toggle('hidden', viewName !== 'builder');
        
        if(viewName === 'builder') {
            requestAnimationFrame(renderBuilder);
        }
    }
    document.getElementById('nav-trainer').addEventListener('click', () => switchView('trainer'));
    document.getElementById('nav-builder').addEventListener('click', () => switchView('builder'));
    document.getElementById('apply-architecture-btn').addEventListener('click', () => {
        fullResetNN();
        switchView('trainer');
    });

    applyNNPreset('xor');
    document.querySelector('#three-d-view-selector button[data-view="output"]').classList.add('active');
    switchView('trainer');

</script>
</body>
</html>

